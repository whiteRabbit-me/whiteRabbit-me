<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>netty</title>
    <link href="/2024/09/14/netty/"/>
    <url>/2024/09/14/netty/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="NIO基础"><a href="#NIO基础" class="headerlink" title="NIO基础"></a>NIO基础</h2><h3 id="1-三大组件"><a href="#1-三大组件" class="headerlink" title="1.三大组件"></a>1.三大组件</h3><h4 id="1-1channel-Buffer"><a href="#1-1channel-Buffer" class="headerlink" title="1.1channel&amp;Buffer"></a>1.1channel&amp;Buffer</h4><blockquote><p>channel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel将数据读入buffer，也可以将buffer的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p></blockquote><p><img src="/D:/笔记\myblog\whiteRabbit-me.github.io\source_posts\netty\image-20240917164333867.png" alt="image-20240917164333867"></p><p>1.常见的Channel有</p><blockquote><p>FileChannel</p><p>DatagramChannel</p><p>SocketChannel</p><p>ServerSocketChannela</p></blockquote><p>2.buffer则用来缓冲读写数据，常见的buffer有</p><blockquote><ul><li>ByteBuffer  这个是抽象类，下面是实现类<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBUffer</li><li>CharBuffer</li></ul></blockquote><h4 id="1-2Selector"><a href="#1-2Selector" class="headerlink" title="1.2Selector"></a>1.2Selector</h4><blockquote><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p></blockquote><h5 id="多线程版设计"><a href="#多线程版设计" class="headerlink" title="多线程版设计"></a>多线程版设计</h5><pre><code class=" mermaid">graph TDsubgraph 多线程版t1(thread) --&gt; s1(socket1)t2(thread) --&gt; s2(socket2)t3(thread) --&gt; s3(socket3)end</code></pre><h5 id="⚠️-多线程版缺点"><a href="#⚠️-多线程版缺点" class="headerlink" title="⚠️ 多线程版缺点"></a>⚠️ 多线程版缺点</h5><ul><li>内存占用高</li><li>线程上下文切换成本高</li><li>只适合连接数少的场景</li></ul><h5 id="线程池版设计"><a href="#线程池版设计" class="headerlink" title="线程池版设计"></a>线程池版设计</h5><pre><code class=" mermaid">graph TDsubgraph 线程池版t4(thread) --&gt; s4(socket1)t5(thread) --&gt; s5(socket2)t4(thread) -.-&gt; s6(socket3)t5(thread) -.-&gt; s7(socket4)end</code></pre><h5 id="⚠️-线程池版缺点"><a href="#⚠️-线程池版缺点" class="headerlink" title="⚠️ 线程池版缺点"></a>⚠️ 线程池版缺点</h5><ul><li>阻塞模式下，线程仅能处理一个 socket 连接</li><li>仅适合短连接场景</li></ul><h5 id="selector-版设计"><a href="#selector-版设计" class="headerlink" title="selector 版设计"></a>selector 版设计</h5><p>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）</p><pre><code class=" mermaid">graph TDsubgraph selector 版thread --&gt; selectorselector --&gt; c1(channel)selector --&gt; c2(channel)selector --&gt; c3(channel)end</code></pre><p>调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理</p><h3 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2.ByteBuffer"></a>2.ByteBuffer</h3><p>有一普通文本文件 data.txt，内容为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1234567890abcd<br></code></pre></td></tr></table></figure><p>使用 FileChannel 来读取文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;helloword/data.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>            <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 向 buffer 写入</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>                log.debug(<span class="hljs-string">&quot;读到字节数：&#123;&#125;&quot;</span>, len);<br>                <span class="hljs-keyword">if</span> (len == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 切换 buffer 读模式</span><br>                buffer.flip();<br>                <span class="hljs-keyword">while</span>(buffer.hasRemaining()) &#123;<br>                    log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, (<span class="hljs-type">char</span>)buffer.get());<br>                &#125;<br>                <span class="hljs-comment">// 切换 buffer 写模式</span><br>                buffer.clear();<br>            &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - 读到字节数：<span class="hljs-number">10</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">1</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">2</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">3</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">4</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">5</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">6</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">7</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">8</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">9</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-number">0</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - 读到字节数：<span class="hljs-number">4</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-selector-tag">a</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - <span class="hljs-selector-tag">b</span><br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - c<br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - d<br><span class="hljs-number">10</span>:<span class="hljs-number">39</span>:<span class="hljs-number">03</span> <span class="hljs-selector-attr">[DEBUG]</span> <span class="hljs-selector-attr">[main]</span> c<span class="hljs-selector-class">.i</span><span class="hljs-selector-class">.n</span><span class="hljs-selector-class">.ChannelDemo1</span> - 读到字节数：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="2-1-ByteBuffer-正确使用姿势"><a href="#2-1-ByteBuffer-正确使用姿势" class="headerlink" title="2.1  ByteBuffer 正确使用姿势"></a>2.1  ByteBuffer 正确使用姿势</h4><ol><li>向 buffer 写入数据，例如调用 channel.read(buffer)</li><li>*调用 flip() 切换至<strong>读模式</strong></li><li>从 buffer 读取数据，例如调用 buffer.get()</li><li>*调用 clear() 或 compact() 切换至<strong>写模式</strong></li><li>重复 1~4 步骤</li></ol><blockquote><p>注意：这里只要记得用flip是读模式，clear,compact是写模式即可，</p><p>下面小节是<strong>讲解</strong>。</p></blockquote><h4 id="2-2-ByteBuffer-结构"><a href="#2-2-ByteBuffer-结构" class="headerlink" title="2.2 ByteBuffer 结构"></a>2.2 ByteBuffer 结构</h4><p>ByteBuffer 有以下重要属性</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>一开始</p><p><img src="/D:/笔记\myblog\whiteRabbit-me.github.io\source_posts\netty\0021.png"></p><p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p><p><img src="/D:/笔记\myblog\whiteRabbit-me.github.io\source_posts\netty\0018.png"></p><p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p><p><img src="/D:/笔记\myblog\whiteRabbit-me.github.io\source_posts\netty\0019.png"></p><p>读取 4 个字节后，状态</p><p><img src="/D:/笔记\myblog\whiteRabbit-me.github.io\source_posts\netty\0020.png"></p><p>clear 动作发生后，状态</p><p><img src="/D:/笔记\myblog\whiteRabbit-me.github.io\source_posts\netty\0021.png"></p><p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p><p><img src="/D:/笔记\myblog\whiteRabbit-me.github.io\source_posts\netty\0022.png"></p><h5 id="💡-调试工具类"><a href="#💡-调试工具类" class="headerlink" title="💡 调试工具类"></a>💡 调试工具类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufferUtil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] BYTE2CHAR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] HEXDUMP_TABLE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">256</span> * <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXPADDING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">16</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">65536</span> &gt;&gt;&gt; <span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTE2HEX = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] BYTEPADDING = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">16</span>];<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] DIGITS = <span class="hljs-string">&quot;0123456789abcdef&quot;</span>.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>            HEXDUMP_TABLE[i &lt;&lt; <span class="hljs-number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0x0F</span>];<br>            HEXDUMP_TABLE[(i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>] = DIGITS[i &amp; <span class="hljs-number">0x0F</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-comment">// Generate the lookup table for hex dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXPADDING.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">padding</span> <span class="hljs-operator">=</span> HEXPADDING.length - i;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(padding * <span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(<span class="hljs-string">&quot;   &quot;</span>);<br>            &#125;<br>            HEXPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">12</span>);<br>            buf.append(NEWLINE);<br>            buf.append(Long.toHexString(i &lt;&lt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));<br>            buf.setCharAt(buf.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            buf.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>            HEXDUMP_ROWPREFIXES[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-hex-dump conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;<br>            BYTE2HEX[i] = <span class="hljs-string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte dump paddings</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">padding</span> <span class="hljs-operator">=</span> BYTEPADDING.length - i;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(padding);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; padding; j++) &#123;<br>                buf.append(<span class="hljs-string">&#x27; &#x27;</span>);<br>            &#125;<br>            BYTEPADDING[i] = buf.toString();<br>        &#125;<br><br>        <span class="hljs-comment">// Generate the lookup table for byte-to-char conversion</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0x1f</span> || i &gt;= <span class="hljs-number">0x7f</span>) &#123;<br>                BYTE2CHAR[i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                BYTE2CHAR[i] = (<span class="hljs-type">char</span>) i;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印所有内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debugAll</span><span class="hljs-params">(ByteBuffer buffer)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldlimit</span> <span class="hljs-operator">=</span> buffer.limit();<br>        buffer.limit(buffer.capacity());<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(origin, buffer, <span class="hljs-number">0</span>, buffer.capacity());<br>        System.out.println(<span class="hljs-string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);<br>        System.out.println(origin);<br>        buffer.limit(oldlimit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印可读取内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debugRead</span><span class="hljs-params">(ByteBuffer buffer)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">256</span>);<br>        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());<br>        System.out.println(<span class="hljs-string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);<br>        System.out.printf(<span class="hljs-string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());<br>        System.out.println(builder);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendPrettyHexDump</span><span class="hljs-params">(StringBuilder dump, ByteBuffer buf, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<br>                    <span class="hljs-string">&quot;expected: &quot;</span> + <span class="hljs-string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="hljs-string">&quot;) &lt;= offset + length(&quot;</span> + length<br>                            + <span class="hljs-string">&quot;) &lt;= &quot;</span> + <span class="hljs-string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dump.append(<br>                <span class="hljs-string">&quot;         +-------------------------------------------------+&quot;</span> +<br>                        NEWLINE + <span class="hljs-string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +<br>                        NEWLINE + <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">startIndex</span> <span class="hljs-operator">=</span> offset;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">fullRows</span> <span class="hljs-operator">=</span> length &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">remainder</span> <span class="hljs-operator">=</span> length &amp; <span class="hljs-number">0xF</span>;<br><br>        <span class="hljs-comment">// Dump the rows which have 16 bytes.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; row &lt; fullRows; row++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowStartIndex</span> <span class="hljs-operator">=</span> (row &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br><br>            <span class="hljs-comment">// Per-row prefix.</span><br>            appendHexDumpRowPrefix(dump, row, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowEndIndex</span> <span class="hljs-operator">=</span> rowStartIndex + <span class="hljs-number">16</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// ASCII dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Dump the last row which has less than 16 bytes.</span><br>        <span class="hljs-keyword">if</span> (remainder != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowStartIndex</span> <span class="hljs-operator">=</span> (fullRows &lt;&lt; <span class="hljs-number">4</span>) + startIndex;<br>            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);<br><br>            <span class="hljs-comment">// Hex dump</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rowEndIndex</span> <span class="hljs-operator">=</span> rowStartIndex + remainder;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(HEXPADDING[remainder]);<br>            dump.append(<span class="hljs-string">&quot; |&quot;</span>);<br><br>            <span class="hljs-comment">// Ascii dump</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;<br>                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);<br>            &#125;<br>            dump.append(BYTEPADDING[remainder]);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br><br>        dump.append(NEWLINE +<br>                <span class="hljs-string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendHexDumpRowPrefix</span><span class="hljs-params">(StringBuilder dump, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> rowStartIndex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;<br>            dump.append(HEXDUMP_ROWPREFIXES[row]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dump.append(NEWLINE);<br>            dump.append(Long.toHexString(rowStartIndex &amp; <span class="hljs-number">0xFFFFFFFFL</span> | <span class="hljs-number">0x100000000L</span>));<br>            dump.setCharAt(dump.length() - <span class="hljs-number">9</span>, <span class="hljs-string">&#x27;|&#x27;</span>);<br>            dump.append(<span class="hljs-string">&#x27;|&#x27;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getUnsignedByte</span><span class="hljs-params">(ByteBuffer buffer, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">short</span>) (buffer.get(index) &amp; <span class="hljs-number">0xFF</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-ByteBuffer-常见方法"><a href="#2-3-ByteBuffer-常见方法" class="headerlink" title="2.3 ByteBuffer 常见方法"></a>2.3 ByteBuffer 常见方法</h4><h5 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h5><p>可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Bytebuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);  <span class="hljs-comment">//java 堆内存，读写效率较低，受到GC的影响</span><br><span class="hljs-type">Bytebuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span>ByteBuffer.allocateDirect(<span class="hljs-number">16</span>) <span class="hljs-comment">//直接内存，读写效率高(少一次拷贝)，不会受GC影响，分配内存低下，使用不当oom，要及时释放内存</span><br></code></pre></td></tr></table></figure><h5 id="向-buffer-写入数据"><a href="#向-buffer-写入数据" class="headerlink" title="向 buffer 写入数据"></a>向 buffer 写入数据</h5><p>有两种办法</p><ul><li>调用 channel 的 read 方法</li><li>调用 buffer 自己的 put 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(buf);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">buf.put((<span class="hljs-type">byte</span>)<span class="hljs-number">127</span>);<br></code></pre></td></tr></table></figure><h5 id="从-buffer-读取数据"><a href="#从-buffer-读取数据" class="headerlink" title="从 buffer 读取数据"></a>从 buffer 读取数据</h5><p>同样有两种办法</p><ul><li>调用 channel 的 write 方法</li><li>调用 buffer 自己的 get 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">writeBytes</span> <span class="hljs-operator">=</span> channel.write(buf);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buf.get();<br></code></pre></td></tr></table></figure><p>get 方法会让 position 读指针向后走，如果想重复读取数据</p><ul><li>可以调用 <code>rewind </code>方法将 position 重新置为 0</li><li>或者调用<code>get(int i)</code>方法获取索引 i 的内容，<strong>它不会移动读指针</strong></li></ul><h5 id="mark-和-reset"><a href="#mark-和-reset" class="headerlink" title="mark 和 reset"></a>mark 和 reset</h5><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p><blockquote><p><strong>注意</strong></p><p><strong>rewind 和 flip 都会清除 mark 位置</strong></p></blockquote><h5 id="字符串与-ByteBuffer-互转"><a href="#字符串与-ByteBuffer-互转" class="headerlink" title="字符串与 ByteBuffer 互转"></a>字符串与 ByteBuffer 互转</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.字符串转byteBuffer</span><br>    ByteBuffer buffer1=ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>buffer1.put(<span class="hljs-string">&quot;hello&quot;</span>.getrBytes());<br><span class="hljs-comment">//这个注意，这种方式ByteBuffer还是写模式，需要利用flip变成读模式才能读取数据</span><br><span class="hljs-comment">//2.wrap 包装 这个直接就是读模式，直接读取</span><br>   BVyteBuffer buffer3=ByteBuffer.wrap(<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<br><span class="hljs-comment">//3.这个直接就是读模式，直接读取</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer1</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer2</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>).encode(<span class="hljs-string">&quot;你好&quot;</span>);<br><br>debug(buffer1);<br>debug(buffer2);<br><span class="hljs-comment">//ByteBuffer转String</span><br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buffer3</span> <span class="hljs-operator">=</span> StandardCharsets.UTF_8.decode(buffer1);<br>System.out.println(buffer3.getClass());<br>System.out.println(buffer3.toString());<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>class java.nio.HeapCharBuffer<br>你好<br></code></pre></td></tr></table></figure><h5 id="⚠️-Buffer-的线程安全"><a href="#⚠️-Buffer-的线程安全" class="headerlink" title="⚠️ Buffer 的线程安全"></a>⚠️ Buffer 的线程安全</h5><blockquote><p>Buffer 是<strong>非线程安全的</strong></p></blockquote><h4 id="2-4-Scattering-Reads"><a href="#2-4-Scattering-Reads" class="headerlink" title="2.4 Scattering Reads"></a>2.4 Scattering Reads</h4><p>分散读取，有一个文本文件 3parts.txt</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">onetwothree</span><br></code></pre></td></tr></table></figure><p>使用如下方式读取，可以将数据填充至多个 buffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;helloword/3parts.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>)) &#123;<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>    channel.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuffer</span>[]&#123;a, b, c&#125;);<br>    a.flip();<br>    b.flip();<br>    c.flip();<br>    debug(a);<br>    debug(b);<br>    debug(c);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 6f 6e 65                                        |one             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 74 77 6f                                        |two             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 74 68 72 65 65                                  |three           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h4 id="2-5-Gathering-Writes"><a href="#2-5-Gathering-Writes" class="headerlink" title="2.5 Gathering Writes"></a>2.5 Gathering Writes</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux文章</title>
    <link href="/2024/09/12/Linux%E5%85%A5%E9%97%A8/"/>
    <url>/2024/09/12/Linux%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Liunx"><a href="#Liunx" class="headerlink" title="Liunx"></a>Liunx</h1><h2 id="1-网络连接三种方式"><a href="#1-网络连接三种方式" class="headerlink" title="1.网络连接三种方式"></a>1.网络连接三种方式</h2><p>1.桥接模式，虚拟系统可以和外部系统通讯，但是容易造成IP冲突</p><p>2.NAT模式，网络地址转换模式。虚拟系统可以和外部系统通讯，不造成IP冲突</p><p>3.主机模式:独立的系统 （不与外界网络连接，想怎么配，怎么配）</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240902111447613.png" class title="image-20240902111447613"><h2 id="2-虚拟机克隆"><a href="#2-虚拟机克隆" class="headerlink" title="2.虚拟机克隆"></a>2.虚拟机克隆</h2><blockquote><p>迁移虚拟机</p></blockquote><p>方式一：直接找到你安装的虚拟机，复制这个目录到新的环境，再通过vm打开即可（easy）</p><p>方式二：vm克隆，需要先关闭Linux系统。（右击你克隆的虚拟机—》管理—-&gt;克隆，根据步骤完成（采用完全克隆的方式，不采用引用的方式））</p><h2 id="3-虚拟机快照"><a href="#3-虚拟机快照" class="headerlink" title="3.虚拟机快照"></a>3.虚拟机快照</h2><blockquote><p>将系统回到初始状态或你保存的状态</p></blockquote><p>右击你的虚拟机—》快照—》拍摄快照（快照管理可以查看你每次的快照）</p><h2 id="4-虚拟机的迁移"><a href="#4-虚拟机的迁移" class="headerlink" title="4.虚拟机的迁移"></a>4.虚拟机的迁移</h2><blockquote><p>迁移和克隆是一样的（找对安装目录即可）</p></blockquote><h2 id="5-vmtools的安装"><a href="#5-vmtools的安装" class="headerlink" title="5.vmtools的安装"></a>5.vmtools的安装</h2><p><strong>在linux中安装</strong></p><blockquote><p>安装vmtools的步骤</p><p>1.进入centos点击vm菜单的-&gt;install vmware toolscentos</p><p>2.会出现一个vm的安装包，xx.tar.gz</p><p>3.拷贝到 &#x2F;opt</p><p>4.使用解压命令 tar, 得到一个安装文件</p><p>5.进入该vm解压的目录，&#x2F;opt 目录下</p><p>6.安装.&#x2F;vmware-install.pl</p><p>7.全部使用默认设置即可，就可以安装成功</p><p>注意:安装vmtools需要有gcc.</p></blockquote><p><strong>在vm中设置</strong></p><blockquote><p>基本介绍</p><p>​为了方便，可以设置一个共享文件夹，比如d:&#x2F;myshare</p><p>具体步骤<br>    1.工菜单-&gt;vm-&gt;setting,如图设置即可注意:设置选项为always enable这样可以读写了</p><p>​2.windows和centos可共享 d:&#x2F;myshare目录可以读写文件了</p><p>​3.共享文件夹在centos的&#x2F;mnt&#x2F;hgfs&#x2F;下</p><p><strong>注意事项和细节说明</strong></p><p>​windows 和 contos 就可以共享文件了，但是在实际开发中，文件的上传下载是需要使用 远程方式完成的</p><p>远程方式登录，借助第三方工具xfrp等</p></blockquote><h2 id="6-Linux目录结构"><a href="#6-Linux目录结构" class="headerlink" title="6.**Linux目录结构"></a>6.**Linux目录结构</h2><p>&#x2F;bin</p><p>&#x2F;sbin</p><p>&#x2F;home</p><p>&#x2F;root</p><p>&#x2F;lib</p><p>&#x2F;lost&#x2F;found</p><p>&#x2F;etc</p><p>&#x2F;usr</p><p>&#x2F;boot</p><p>&#x2F;proc   <strong>不能动</strong></p><p>&#x2F;srv  <strong>不能动</strong></p><p>&#x2F;sys  <strong>不能动</strong></p><p>&#x2F;tmp</p><p>&#x2F;dev   所有的硬件都在这个文件下 （例如：硬盘）</p><p>&#x2F;media</p><p>&#x2F;mnt</p><p>&#x2F;opt</p><p>&#x2F;usr&#x2F;local</p><p>&#x2F;var</p><p>&#x2F;selinux</p><h2 id="7-Linux远程登录和文件传输"><a href="#7-Linux远程登录和文件传输" class="headerlink" title="7.Linux远程登录和文件传输"></a>7.Linux远程登录和文件传输</h2><p>使用xshell xftp</p><h2 id="8-vi-vim的使用"><a href="#8-vi-vim的使用" class="headerlink" title="8.vi vim的使用"></a>8.vi vim的使用</h2><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240903151245297-17253475680882.png" class title="image-20240903151245297"><h2 id="9-linux关机重启"><a href="#9-linux关机重启" class="headerlink" title="9.linux关机重启"></a>9.linux关机重启</h2><ul><li>shutdown -h now  立刻关机</li><li>shutdown -h 1  1分钟后关机  和shutdown一样</li><li>shutdown -r now  现在重新启动计算机</li><li>halt  关机，作用和shutdown -h now  立刻关一样</li><li>reboot  现在重新启动计算机</li><li>sync <strong>把内存的数据同步到磁盘</strong></li></ul><p><strong>注意细节</strong></p><ul><li>​不管是重启系统还是关闭系统，首先要运行svnc命令，把内存中的数据写到磁盘中</li><li>​目前的 shutdown&#x2F;reboot&#x2F;halt 等命令均已经在关机前进行了 sync ，老韩提醒: 小心驶得万年船</li></ul><h2 id="10-登录注销"><a href="#10-登录注销" class="headerlink" title="10.登录注销"></a>10.登录注销</h2><blockquote><p>logout：注销—-&gt;在运行级别3中有效，也就是无界面</p></blockquote><blockquote><p>su - root 切换到root下  ，logout则回到登录用户，再logout则退出</p></blockquote><h2 id="11-用户管理"><a href="#11-用户管理" class="headerlink" title="11.用户管理"></a>11.用户管理</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>1.添加用户</p><blockquote><p>useradd  用户名      解释：添加用户</p><p>useradd -d 目录  用户名   例如：useradd -d &#x2F;home&#x2F;test king  表示test为king用户管理的目录</p><p>useradd -g 用户组 用户名   解释：增加用户时直接加上组</p></blockquote><p>2.修改用户密码或设置密码</p><blockquote><p>passwd 用户名  给这个用户名设置密码或修改密码</p></blockquote><p>3.删除用户</p><blockquote><p>userdel 用户名</p><p>应用案例：</p><p>1.删除用户，保留用户目录 —–》userdel 用户名</p><p>2.删除用户和用户目录——》userdel -r 用户名 <strong>慎重</strong></p></blockquote><p>4.查询用户</p><blockquote><p>id 用户名</p></blockquote><p>5.切换用户</p><blockquote><p>su - 用户名</p><p>注：权限高的向权限低的，不需要密码</p><p>​回到原来用户-》》logout或exit</p></blockquote><p>6.查看当前第一次登录的用户（su - 换用户后  查看的还是第一登录的用户）</p><blockquote><p>whoami  或  who am i</p></blockquote><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>1.新增用户组</p><blockquote><p>groupadd 组名</p></blockquote><p>2.删除组</p><blockquote><p>groupdel 组名</p></blockquote><p>3.增加用户时直接加上组</p><blockquote><p>useradd -g 用户组 用户名</p></blockquote><p>4.修改用户的组  用root用户修改组</p><blockquote><p>usermod -g 用户组 用户名</p><p>usermod -d 目录名 用户名  改变改用户登录的初始目录 。 <strong>注意：</strong>用户需要有进入到新目录的权限</p></blockquote><h3 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h3><p>&#x2F;etc&#x2F;passwd 文件</p><ul><li>用户(user)的配置文件，记录用户的各种信息</li><li>每行的含义:用户名:口令(一般这里是x ，加密):用户标识号:组标识号:注释性描述:主目录:登录Shell</li></ul><p>&#x2F;etc&#x2F;shadow 文件</p><ul><li><p>口令的配置文件</p></li><li><p>每行的含义:登录名:加密口令(密码：加密的，！是没有密码):最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</p></li></ul><p>&#x2F;etc&#x2F;group 文件</p><ul><li>组(group)的配置文件，记录Linux包含的组的信息</li><li>每行含义:组名:口令:组标识号:组内用户列表</li></ul><h2 id="12-指定运行级别"><a href="#12-指定运行级别" class="headerlink" title="12.指定运行级别"></a>12.指定运行级别</h2><blockquote><p>基本介绍运行级别说明:<br>0:关机</p><p>1:单用户 (找回丢失密码)</p><p>2:多用户状态没有网络服务  (无意义)</p><p>3.多用户状态有网络服务</p><p>4:系统未使用保留给用户 （现在无意义）</p><p>5:图形界面</p><p>6:系统重启</p><p>注意：常用运行级别是3和5，也可以指定默认运行级别（可以设置），后面演示</p><p><strong>应用实例</strong></p><p>命令:init [0123456]</p><p>​    应用案例:通过init 来切换不同的运行级别，比如动 5-3 ，然后关机</p></blockquote><h3 id="指定默认运行级别"><a href="#指定默认运行级别" class="headerlink" title="指定默认运行级别"></a>指定默认运行级别</h3><blockquote><p>在centos7以前，&#x2F;etc&#x2F;inittab文件中修改</p><p>centos7以后，进行了简化，如下命令</p><ul><li>multi-user.target:类似于运行级别3</li><li>graphical.target:类似于运行级别5</li></ul></blockquote><p>1.查看当前默认运行级别</p><blockquote><p>systemctl get-default</p></blockquote><p>2.修改默认运行级别  (例子：运行级别5)</p><p>systemctl set-default graphical.target</p><h2 id="13-找回root密码"><a href="#13-找回root密码" class="headerlink" title="13.找回root密码"></a>13.找回root密码</h2><blockquote><p>注意：（不同版本，不太一样，这里是centos7.6以后   这次演示的是7.6）</p></blockquote><p>1.首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面，如图</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904102536814-17254167381663.png" class title="image-20240904102536814"><p>2.进入编辑界面，使用键盘上的上下键把光标往下移动，找到以““Linux16”开头内容所在的行数”,在行的最后面输入:init&#x3D;&#x2F;bin&#x2F;sh。<br>如图</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904102908699-17254169496725.png" class title="image-20240904102908699"><p>3.接者，输入完成后，直接按快捷键:Ctrl+x 进入单用户模式，<br>4.接着，在光标闪烁的位置中输入:<code>mount -o remount,rw / </code> (注意:各个单词间有空格)，完成后按键盘的回车键(Entcr)。如图</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904103018574-17254170195896.png" class title="image-20240904103018574"><p>5.在新的一行最后面输入:passwd， 完成后按键盘的回车键(Ener)。输入密码，然后再次确认密码即可(提示:密码长度最好8位以上,但不是必须的)，密码修改成功后，会显示passwd…的样式，说明密码修改成功</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904103125459-17254170864547.png" class title="image-20240904103125459"><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904103415223-17254172564548.png" class title="image-20240904103415223"><p>7.接着，在鼠标闪烁的位置中(最后一行中)输入:<code>touch /.autorelabel</code>(注意:touch与&#x2F;后面有一个空格)，完成后按键盘的回车键(Enter)</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904103817805-172541749908910.png" class title="image-20240904103817805"><p>8.继续在光标闪烁的位置中，输入:<code>exec /sbin/init</code>(注意:exec与&#x2F;后面有一个空格)，完成后按键盘的回车键(Enter)，等待系统自动修改密码( 提示:这个过程时间可能有点长，耐心等待)，完成后，系统会自动重启，新的密码生效了</p><p>【可选】最后进入后，可再根据<code>passwd root </code>改你想改的密码</p><h2 id="14-帮助命令"><a href="#14-帮助命令" class="headerlink" title="14.帮助命令"></a>14.帮助命令</h2><p>man 获得帮助信息</p><ul><li>基本语法:man 命令或配置文件(功能描述:获得帮助信息)</li><li>案例:查看Is命令的帮助信息  <code>man ls</code>  (空格翻页)</li></ul><p>help指令</p><ul><li>基本语法:help 命令(功能描述:获得shell内置命令的帮助信息)</li></ul><p>应用实例</p><ul><li>案例:查看cd命令的帮助信息  <code>help cd</code></li></ul><p>百度帮助更直接<br>如果英语不太好的，也可以直接百度靠谱</p><h2 id="15-文件目录类-pwd-ls-ln…"><a href="#15-文件目录类-pwd-ls-ln…" class="headerlink" title="15.文件目录类-pwd-ls-ln….."></a>15.文件目录类-pwd-ls-ln…..</h2><blockquote><p>pwd：显示绝对路径</p></blockquote><blockquote><p>ls</p><p>​-l :列表显示</p><p>​-a ：全部显示</p><p>​-h:   展示信息更容易理解</p><p>​-R：递归展示</p></blockquote><blockquote><p>cd</p><p>​~ :回到用户目录</p><p>​.. :回到上级目录</p></blockquote><blockquote><p>mkdir</p><p>​-p：创建多级目录</p></blockquote><blockquote><p>rmdir :只能删除空目录</p><p>rm -rf   ：递归强制删除，危险</p></blockquote><blockquote><p>touch  :创建文件，会修改文件时间</p></blockquote><blockquote><p>cp   :拷贝指令</p><p>​cp [选项] 源 目标</p><p>​-r :递归拷贝</p><p>​\cp :强制覆盖代替cp命令</p></blockquote><blockquote><p>rm  :删除文件</p><p>​-r  递归删除目录</p><p>​-f  不提示强制删除</p></blockquote><blockquote><p>mv 重命名和移动文件</p><p>​mv 源文件  目标</p></blockquote><blockquote><p>cat  ：查看文件内容</p><p>​-n :显示行号</p><p>​经常用法  cat -n xxx | more   :cat配合管道 查询结果用more交换   回车下行   空格翻页</p></blockquote><blockquote><p>more more指令是一个基于V编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more<br>指令中内置了若干快捷键(交互的指令)，详见操作说明</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904122520380-172542392194912.png" class title="image-20240904122520380"></blockquote><blockquote><p>less ::查大文件，效率好</p><p>less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904132457418-172542749889313.png" class title="image-20240904132457418"></blockquote><blockquote><p>echo ：输出内容到控制台</p><p>​例如：输出环境变量：echo $HOSTNAME</p></blockquote><blockquote><p>head :head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p><p>​-n 5  :显示前5行</p></blockquote><blockquote><p>tail  :tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的前10行内容。</p><p>​-n</p><p>​-f :实时的追踪文档的更新</p></blockquote><blockquote><p>理解：能显示的都能写道文件中</p><p>·&gt;·    输出重定向   例如：echo “hello” &gt;  a.txt  （会覆盖）</p><p>·&gt;&gt;·  追加   例如：echo “hello” &gt;&gt;  a.txt   （追加） </p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904142458798-172543109990714.png" class title="image-20240904142458798"></blockquote><blockquote><p>ln :软链接也称为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径</p><p>语法：<code>ln -s 原文件或目录 软链接名</code>    ：给原文件创建一个软链接  类似于win的快捷方式</p><p>应用案例  <code>ln -s /root /home/myroot   </code></p><p><code>rm /home/myroot</code>   :删除软连接</p></blockquote><blockquote><p><code>history </code>  ：查看历史使用命令</p><ul><li><p><code>history 10</code>  :表示查看最近使用的10条命令</p></li><li><p>通过下面方式重新执行</p><ul><li><p><code>!编号</code>     ：这个编号是用history查看的那个命令前的编号   意思是把这个命令重新执行一遍，或者<strong>直接重新打一遍</strong></p></li><li><p><code>!</code>字母也下，如我曾经使用过<code>tail</code>  <code>!t</code>就会从history从下往上匹配<code>t</code>开头的，太久的不建议这样使用</p></li><li><p>那如何找久远的命令呢，先执行<code>history</code> 再按 <code>ctrl+r</code> 搜寻你想搜寻的关键字即可，搜寻规则也是从下往上匹配</p></li></ul></li></ul></blockquote><h2 id="16-时间日期指令"><a href="#16-时间日期指令" class="headerlink" title="16.时间日期指令"></a>16.时间日期指令</h2><blockquote><p>date   显示当前日期</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904145304827-172543278616215.png" class title="image-20240904145304827"><p>​-s  字符串时间    ：设置系统当前时间  例如：date -s “2024-09-04 14:02:55”</p></blockquote><blockquote><p><code>cal</code>   查看当前月份的日历</p><p><code>cal 2024</code>   :展示2024的1-12的日历</p></blockquote><h2 id="17-查找指令-find-locate-which-grep"><a href="#17-查找指令-find-locate-which-grep" class="headerlink" title="17.查找指令-find-locate -which-grep"></a>17.查找指令-find-locate -which-grep</h2><blockquote><p>find    find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p><p>语法：find 搜索范围  选项</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904150048461-172543324985916.png" class title="image-20240904150048461"><p>例如：</p><p>​find &#x2F;home -name hello.txt</p><p>​find &#x2F;opt  -user nobody   :查找&#x2F;opt目录下，用户名为nobody的文件</p><p>​find &#x2F; -size +200M    查找整个linux大于200M的文件  （+大于 -小于 不写则是等于  ，单位有k,M,G）</p></blockquote><blockquote><p>locate  :locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，<strong>管理员必须定期更新locate时刻</strong></p><p>基本语法<br>locate 搜索文件<br>特别说明<br>由于locate指令基于数据库进行查询，所以<strong>第一次运行前，必须使用<code>updatedb</code>指令创建locate数据库</strong></p></blockquote><blockquote><p>which   ：可以查看某个指令在那个目录下  例如ls  which ls</p></blockquote><blockquote><p>grep 和管道符号  |</p><p>​grep 过滤查找     语法：grep  选项  查找内容  源文件  </p><p>​-n  显示行号</p><p>​-i  忽略大小写</p><p>​-v 反向匹配（就是包含某个过滤条件的不要查询）</p><p>​管道符 |  表示将前一个命令的处理结果输出传递给后面的命令处理</p><p>解释图：</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904153637713-172543539910017.png" class title="image-20240904153637713"><p>cat  a.txt | grep  -n “yes”</p><p>grep -n “yes”  a.text</p></blockquote><h2 id="18-压缩和解压"><a href="#18-压缩和解压" class="headerlink" title="18.压缩和解压"></a>18.压缩和解压</h2><blockquote><p>gzip&#x2F;gunzip   :压缩文件</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904154143453-172543570473718.png" class title="image-20240904154143453"></blockquote><blockquote><p>zip&#x2F;unzip   :zip 用于压缩文件&#x2F;文件夹，unzip 用于解压文件&#x2F;文件夹，这个在项目打包发布中很有用的</p><p>语法：</p><p>​zip 选项 xxx.zip  压缩的内容</p><p>​-r 递归压缩，即压缩目录</p><p>​unzip 选项 xxx.zip  </p><p>​-d&lt;目录&gt; 指定解压后文件的存放目录</p><p>案例：</p><p>​zip -r xxx.zip  &#x2F;home&#x2F;</p><p>​unzip -d &#x2F;opt&#x2F; &#x2F;home&#x2F;xxx.zip</p><p>讲解图如下：</p><p>​ <img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904155231792-172543635310719.png" class title="image-20240904155231792"></p></blockquote><blockquote><p>tar  打包和解压看选项的选择</p><p>语法：</p><p>​<code>tar 选项  xx.tar.gz  打包内容</code></p><p>​选项</p><p>​-c 产生打包文件，产生<code>.tar</code>打包文件</p><p>​-v 显示详细信息</p><p>​-f指定压缩后的文件，这个选项是必须的，指定操作涉及的文件名</p><p>​-z打包同时压缩，调用 giz，文件后缀是<code>.gz</code></p><p>​-x解包.tar文件，解包<code>.tar</code>文件</p><p>​-j     调用 bzip2，文件后缀是<code>.bz2</code></p><p>​-Z    调用 compress，文件后缀是<code>.Z</code></p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904160759353-172543728058120.png" class title="image-20240904160759353"><p>案例：</p><p><code>tar -zxvf   xxx.tar.gz  -C /opt</code>  解压缩到&#x2F;opt</p><p><code>tar -zcvfpc.tar.gz  /home/xxx/a.txt  /home/xxx/b.txt </code>  打包</p><p><strong>举一反三就有<code>tar -jcvf</code>，<code>tar -jxvf</code>，<code>tar -Zcvf</code>和<code>tar -Zxvf</code>等等</strong></p></blockquote><h2 id="19-linux组（难点）"><a href="#19-linux组（难点）" class="headerlink" title="19.linux组（难点）"></a>19.linux组（难点）</h2><blockquote><p>一个文件&#x2F;目录有 所有者 所在组 其他组 ；</p><p>​所有者：某个用户对这个文件的权限，一般是谁创建谁是创建者</p><p>​所在组：是某个组对这个文件的权限，默认是创建者所在的组</p><p>​其他组：其余的组对这个文件的权限</p></blockquote><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240904163445173-172543888627621.png" class title="image-20240904163445173"><h3 id="1-所有者"><a href="#1-所有者" class="headerlink" title="1.所有者"></a>1.所有者</h3><blockquote><p>查看文件的所有者</p><p>​ls -ahl</p></blockquote><blockquote><p>修改文件所有者</p><p>chown 用户名 文件名</p></blockquote><h3 id="2-所在组"><a href="#2-所在组" class="headerlink" title="2.所在组"></a>2.所在组</h3><blockquote><p>修改文件所在组</p><p>chgrp 组名 文件名</p></blockquote><h3 id="3-其他租"><a href="#3-其他租" class="headerlink" title="3.其他租"></a>3.其他租</h3><blockquote><p>除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组</p></blockquote><h3 id="4-改变用户所在组"><a href="#4-改变用户所在组" class="headerlink" title="4.改变用户所在组"></a>4.改变用户所在组</h3><blockquote><p>在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组。</p><ul><li>改变用户所在组<ul><li><code>usermod -g 新组名 用户名</code></li><li><code>usermod -d 目录名 用户名</code>  改变该用户登陆的初始目录。特别说明:用户需要有进入到新目录的权限</li></ul></li><li>应用实例<ul><li>题目：将 zwj 这个用户从原来所在组，修改到 wudang 组。<ul><li>操作：<code>usermod -g wudang zwj</code></li></ul></li></ul></li></ul></blockquote><h2 id="20-rwx权限"><a href="#20-rwx权限" class="headerlink" title="20.rwx权限"></a>20.rwx权限</h2><blockquote><p>权限配合 组 来使用</p></blockquote><h3 id="1-基础分析"><a href="#1-基础分析" class="headerlink" title="1.基础分析"></a>1.基础分析</h3><blockquote><p><code>ls -l </code>查看文件权限</p><ul><li><p>-rwxrw-r– 1 root root 1213 Feb 2 09:39 abc</p></li><li><p>0-9位说明</p><p>1.第0位确定文件类型(d，-，l，c，b)</p><p>​- 是普通文件</p><p>​I 是链接，相当于windows的快捷方式</p><p>​d 是目录，相当于windows的文件夹</p><p>​c 是价门备文件，鼠标，键盘</p><p>​b 是块设备，比如硬盘</p><p>2.第1-3位确定所有者(该文件的所有者)拥有该文件的权限。—User</p><p>3.第4-6位确定所属组(同用户组的)拥有该文件的权限，—Group</p><p>4.第7-9位确定其他用户拥有该文件的权限—Other</p></li></ul></blockquote><blockquote><p><strong>讲解rwx作用并理解</strong>（理解清楚）</p><p>rwx作用到文件 （文件的对象是文件内容）</p><ul><li><p>[r]代表可读(read):可以读取，查看</p></li><li><p>[w]代表可写(write): 可以修改，但是不代表可以删除该文件，<strong>删除一个文件的前提条件是对该名件所在的目录有写权限</strong>，才能删除该文件。</p></li><li><p>[x]代表可执行(execute):可以被执行</p></li></ul><p>rwx作用到目录 （目录的对象是文件本身）</p><ul><li>[r]代表可读(read):    <strong>可以读取，ls查看目录内容</strong>，但目录下文件该有的权限还是有的</li><li>[w ]代表可写(write):  <strong>可以修改,对目录内创建+删除+重命名目录</strong></li><li>[x]代表可执行(execute):    <strong>可以进入该目录   cd操作</strong></li></ul><p>注意：</p></blockquote><blockquote><p><strong>实例讲解</strong></p><p><code>ls -l</code>中显示的内容如下:<br>    -rwxrw-r– 1 root root 1213 Feb 2 09:39 abc</p><p>1.10个字符确定不同用户能对文件干什么</p><ul><li>第一个字符代表文件类型: - l d c b</li></ul><p>其余字符每3个一组(rwx)读(r)写(w)执行(x)</p><ul><li><p>第一组rwx:文件拥有者的权限是读、写和执行</p></li><li><p>第二组rw-:与文件拥有者同一组的用户的权限是读、写但不能执行</p></li><li><p>第三组r–:不与文件拥有者同组的其他用户的权限是读不能写和执行</p></li></ul><p>2.可用数字表示为:r&#x3D;4,w&#x3D;2,x&#x3D;1因此rwx&#x3D;4+2+1&#x3D;7</p><p>3.其它说明</p><p>1   文件 : 硬连接数或目录 : 子目录数+文件数</p><p>root 用户</p><p>root 组</p><p>1213文件大小(字节)，如果是文件夹，显示 4096字节</p><p>Feb 2 09:39最后修改日期</p><p>abc 文件名</p></blockquote><h3 id="2-修改文件-目录权限-chmod"><a href="#2-修改文件-目录权限-chmod" class="headerlink" title="2.修改文件&#x2F;目录权限-chmod"></a>2.修改文件&#x2F;目录权限-chmod</h3><blockquote><p><code>chmod</code></p><p><strong>第一种方式: + - &#x3D; 变更权限</strong></p><p>u:所有者 g:所有组 o:其他人 a:所有人(u、g、o的总和)</p><p>1)<code>chmod u=rwx,g=rx,o=x 文件/目录名</code></p><p>2)<code>chmod o+w 文件/目录名</code></p><p>3)<code>chmod  a-X  文件/目录名</code></p><p><strong>第二种方式:通过数字变更权限</strong></p><p>r&#x3D;4 w&#x3D;2 x&#x3D;1</p><p>rwx&#x3D;4+2+1&#x3D;7</p><p><code>chmod u=rwx,g=rx,o=x 文件目录名</code>相当于 <code>chmod 751 文件目录名</code></p></blockquote><h3 id="3-修改文件所用者-chown"><a href="#3-修改文件所用者-chown" class="headerlink" title="3.修改文件所用者-chown"></a>3.修改文件所用者-chown</h3><blockquote><p>chown</p><p>​<code>chown newowner 文件/目录 </code>  改变所有者</p><p>​<code>chown newowner:newgroup 文件/目录</code>改变所有者和所在组</p><p>选项</p><p>​-R 如果是目录 则使其下所有子文件或目录递归生效</p></blockquote><h3 id="4-修改文件-目录所在组-chgrp"><a href="#4-修改文件-目录所在组-chgrp" class="headerlink" title="4.修改文件&#x2F;目录所在组-chgrp"></a>4.修改文件&#x2F;目录所在组-chgrp</h3><blockquote><p>chgrp</p><p>​<code>chgrp newgroup 文件/目录</code>  修改文件&#x2F;目录所在组</p><p>选项</p><p>​-R 如果是目录 则使其下所有子文件或目录递归生效</p><p>应用实例</p><p>使用 root用户创建文件 orange.xt,看看当前这个文件属于哪个组，然后将这个文件所在组，修改到 fnuit 组</p><ol><li><code>groupadd fruit </code> 创建组</li><li><code>toueh orange.txt</code> 创建文件</li><li>看看当前这个文件属于哪个组-&gt;root 组</li><li><code>chgrp fmit orange.txt</code> 修改文件所在组</li></ol></blockquote><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><blockquote><p>题目：</p><p>police  警察组</p><p>bandit  土匪组</p><p>jack，jerry ：  在警察组<br>xh，xq    ：在土匪组</p><p>1.创建组</p><ul><li><code>groupadd police</code>     <code>groupadd bandit</code></li></ul><p>2.创建用户，并将用户放在对应组中</p><ul><li><code>useradd -g police jack </code></li><li><code>useradd -g police jerry </code></li><li><code>useradd -g bandit xh</code></li><li><code> useradd -g bandit xq</code></li></ul><p>3.jack 创建一个文件，自己可以读r写w，本组人可以读，其它组没人任何权限</p><ul><li><p>首先iack登录:</p><ul><li><p><code>vim jack.txt</code> </p></li><li><p><code> chmod 640 jack.txt</code></p></li></ul></li></ul><p>4.jack修改该文件，让其它组人可以读，本组人可以读写</p><ul><li><code>chmod o=r,g=r jack.txt</code></li></ul><p>5.xh 投靠 警察，看看是否可以读写</p><p><code>usermod -g police xh</code></p><p>6.测试，看看是否可以读写，xg是否可以，小结论，就是如果要对目录内的文件进行操作，需要要有对该目录的相应权限</p></blockquote><h2 id="21-定时任务调度"><a href="#21-定时任务调度" class="headerlink" title="21.定时任务调度"></a>21.定时任务调度</h2><h3 id="1-crond（重复）"><a href="#1-crond（重复）" class="headerlink" title="1.crond（重复）"></a>1.crond（重复）</h3><blockquote><p>crontab 进行定时任务的设置</p><p>概述</p><p>​任务调度:是指系统在某个时间执行的特定的命令或程序。</p><p>​任务调度分类:</p><p>​1.系统工作:有些重要的工作必须周而复始地执行。如病毒扫描等</p><p>​2.个别用户工作:个别用户可能希望执行某些程序，比如对mysql数据库的备份。</p><p>快速入门</p><ul><li><p>设置任务调度文件:&#x2F;etc&#x2F;crontab</p></li><li><p>设置个人任务调度。执行crontab-e命令</p></li></ul><p>基本语法</p><ul><li>crontab[选顶]</li></ul><p>常用选项</p><ul><li><p>-e编辑crontab定时任务</p></li><li><p>-l查询crontab任努</p></li><li><p>-r删除当前用户所有的crontab任务</p></li></ul><p>常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">crontab -e  编辑任务<br>conrtab -r 终止任务调度。全部都没了<br>crontab -l  列出当前有那些任务调度<br>service crond restart 重启任务调度<br></code></pre></td></tr></table></figure><p>如图解释：</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240905140616919-17255163783671.png" class title="image-20240905140616919"><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240905144751921-17255188735122.png" class title="image-20240905144751921"></blockquote><h4 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h4><blockquote><p>1.<code>crontabe -e</code></p><p>2.在文件中输入<code>*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt</code></p><p>解释如下：5个占位符的说明</p><table><thead><tr><th align="center">项目</th><th align="center">含义</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">第一个  “*”</td><td align="center">一小时当中的第几分钟</td><td align="center">0-59</td></tr><tr><td align="center">第二个  “*”</td><td align="center">一天当中的第几小时</td><td align="center">0-23</td></tr><tr><td align="center">第三个  “*”</td><td align="center">一个月当中的第几天</td><td align="center">1-31</td></tr><tr><td align="center">第四个  “*”</td><td align="center">一年当中的第几月</td><td align="center">1-12</td></tr><tr><td align="center">第五个  “*”</td><td align="center">一周当中的星期几</td><td align="center">0-7（0和7都代表星期日）</td></tr></tbody></table></blockquote><h4 id="时间规则"><a href="#时间规则" class="headerlink" title="时间规则"></a>时间规则</h4><table><thead><tr><th align="center">特殊符号</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">代表任何时间，比如第一个 “*” 就代表一小时中每分钟都执行一次的意思。</td></tr><tr><td align="center">,</td><td align="center">代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令</td></tr><tr><td align="center">-</td><td align="center">代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令</td></tr><tr><td align="center">*&#x2F;n</td><td align="center">代表每隔多久执行一次。比如“*&#x2F;10 * * * * 命令”，代表每隔10分钟就执行一遍命令</td></tr></tbody></table><h4 id="一些规则"><a href="#一些规则" class="headerlink" title="一些规则"></a>一些规则</h4><table><thead><tr><th>时间</th><th>含义</th></tr></thead><tbody><tr><td>45 22 * * * 命令</td><td>在22点45分执行命令</td></tr><tr><td>0 17 * * 1命令</td><td>每周1 的17点0分执行命令</td></tr><tr><td>0 5 1,15 * * 命令</td><td>每月1号和15号的凌晨5点0分执行命令</td></tr><tr><td>40 4 * * 1-5 命令</td><td>每周一到周五的凌晨4点40分执行命令</td></tr><tr><td>*&#x2F;10 4 * * * 命令</td><td>每天的凌晨4点，每隔10分钟执行一次命令</td></tr><tr><td>0 0 1,15 * 1 命令</td><td>每月1号和15号，每周1的0点0分都会执行命令。注意:星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱。</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="2-at-一次"><a href="#2-at-一次" class="headerlink" title="2.at(一次)"></a>2.at(一次)</h3><blockquote><p>1.基本介绍</p><ol><li><p>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。</p></li><li><p>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。</p></li><li><p>at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了</p></li><li><p>在使用at命令的时候，<strong>一定要保证证atd进程的启动</strong>，可以使用相关指令来查看</p><ul><li><code>ps -ef | grep atd</code></li></ul></li></ol><p>2.at命令格式</p><p>​at [选项]  [时间]            ## <strong>Ctrl +D 结束at命令 —》输入2次</strong></p><p> [选项] </p><table><thead><tr><th align="center">选项</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-m</td><td align="center">当指定的任务被完成后，将给用户发送邮件，即使没有标准输出</td></tr><tr><td align="center">-I</td><td align="center">atq的别名</td></tr><tr><td align="center">-d</td><td align="center">atrm的别名</td></tr><tr><td align="center">-v</td><td align="center">显示任务将被执行的时间</td></tr><tr><td align="center">-c</td><td align="center">打印任务的内容到标准输出</td></tr><tr><td align="center">-V</td><td align="center">显示版本信息</td></tr><tr><td align="center">-q &lt;队列&gt;</td><td align="center">使用指定的队列</td></tr><tr><td align="center">-f &lt;文件&gt;</td><td align="center">从指定文件读入任务而不是从标准输入读入</td></tr><tr><td align="center">-t &lt;时间参数&gt;</td><td align="center">以时间参数的形式提交要运行的任务</td></tr></tbody></table><p>[时间]  </p><blockquote><p>at时间定义:</p><p>1.接受在当天的hh:mm(小时:分钟)式的时间指定。假如该时间已过去，那么就放在第二天执行。 例如:04:00</p><p>2.使用midnight(深夜)，noon(中午)，teatime(饮茶时间，一般是下午4点)等比较模糊的词语来指定时间。</p><p>3.采用12小时计时制，即在时间后面加上AM(上午)或PM(下午)来说明是上午还是下午。例如:12pm</p><p>4.指定命令执行的具体日期，指定格式为monthday(月 日)或mm&#x2F;dd&#x2F;yy(月&#x2F;日&#x2F;年)或dd.mm.yy(日.月.年)，指定的日期必须跟在指定时间的后面。例如:04:00 2021-03-1</p><p>5.使用相对计时法。指定格式为:now+counttime-units，now就是当前时间，time-units是时间单位这里能够是minutes(分钟)、hours(小时)、days(天)、weeks(星期)。count是时间的数量，几天，几小时。例如:now+5minutes</p><p>6.直接使用today(今天)、tomorrow(明天)来指定完成命令的时间。</p></blockquote><p>3.其他命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep atd  ##先看看atd是否后台运行 一定要有才能用at命令<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">at的使用</span><br>at 5pm + 2 days  ##2天后下午5点中执行<br>/bin/ls /home  ##输入内容，结束后按两次 ctrl+D<br><br>atq   ##查看系统中要执行的工作任务<br>atrm 编号  ##删除此编号的任务<br></code></pre></td></tr></table></figure><p>4.原理解释：</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240905145953345-17255195952973.png" class title="image-20240905145953345"><p>5.案例：</p><blockquote><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240905152212010-17255209334674.png" class title="image-20240905152212010"></blockquote></blockquote><h2 id="22-磁盘分区"><a href="#22-磁盘分区" class="headerlink" title="22.磁盘分区"></a>22.磁盘分区</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote><p>原理介绍</p><p>​Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。</p><p>​Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p><p>示例图：</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240905155111310-17255226754835.png" class title="image-20240905155111310"></blockquote><blockquote><p>linux<strong>硬盘说明</strong></p><ol><li><p>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</p></li><li><p>对于IDE硬盘，驱动器标识符为“hdx<del>”,其中“hd”表明分区所在设备的类型这里是指IDE硬盘“x”为盘号(a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘“</del>”代表分区前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。</p></li><li><p>对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。</p></li></ol></blockquote><h3 id="2-命令-lsblk："><a href="#2-命令-lsblk：" class="headerlink" title="2.命令-lsblk："></a>2.命令-lsblk：</h3><blockquote><ul><li><p>查看所有设备挂载情况</p><ul><li><code>lsblk </code>或者<code>lsblk -f</code></li></ul></li><li><p>结果解释</p></li></ul><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240905160622522-17255235839246.png" class title="image-20240905160622522"></blockquote><h3 id="3-增加磁盘应用实例"><a href="#3-增加磁盘应用实例" class="headerlink" title="3.增加磁盘应用实例"></a>3.增加磁盘应用实例</h3><blockquote><p>说明:</p><p>​下面我们以增加一块硬盘为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。</p><p>问题：如何增加一块硬盘</p><ol><li><p>虚拟机添加硬盘</p><ul><li>在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，至到完成。然后重启系统(才能识别)</li></ul></li><li><p>分区</p><ul><li><p>解释：分区命令<code>fdisk /dev/sdb</code>  解释：给sdb硬盘分区  （sdb，其中b是代表第二块硬盘，具体看上方的<strong>硬盘说明</strong>）</p><ul><li><p>开始对&#x2F;sdb分区</p></li><li><table><thead><tr><th align="center">指令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">m</td><td align="center">显示命令列表</td></tr><tr><td align="center">p</td><td align="center">显示磁盘分区同 fdisk -l</td></tr><tr><td align="center">n</td><td align="center">新增分区</td></tr><tr><td align="center">d</td><td align="center">删除分区</td></tr><tr><td align="center">w</td><td align="center">写入并退出</td></tr></tbody></table></li></ul></li><li><p><strong>具体操作</strong></p><ul><li>输入<code>fdisk /dev/sdb</code>开始分区</li><li>输入n，新增分区，然后选择p，分区类型为主分区。  （选择说明：e 为扩展分区）</li><li>输入1  (这里代表创建分区1)</li><li>两次回车默认剩余全部空间。</li><li>最后输入w写入分区并退出，若不保存退出输入q</li></ul></li><li><p>再次输入<code>lsblk</code>，则看到sdb硬盘下出现分区sdb1</p></li></ul></li><li><p>格式化（给分区指定文件类型）</p><ul><li>可以先看下<code>lsblk -f</code>，发现新建的分区没有文件类型</li><li><strong>格式化操作</strong><ul><li><code>mkfs -t ext4 /dev/sdb1</code>    其中ext4是分区类型 （多个分区 ，多次格式化）</li><li>再次查看<code>lsblk -f</code>，发现有uuid和文件类型了</li></ul></li></ul></li><li><p>挂载–mount（挂载是将一个分区与一个目录联系起来）</p><ul><li><strong>注意：目前为止，命令行挂载是临时的，想要永久则将第五步完成</strong></li><li>语法：<ul><li><code>mount 设备名称 挂载目录</code></li></ul></li><li><strong>实操操作</strong><ul><li>创建目录<code>mkdir newdisk</code>，（此目录是要挂载的目录,这里是根目录创建的，挂载的目录在哪都可以）</li><li>挂载<code>mount /dev/sdb1 /newdisk/</code></li><li>再次查看<code>lsblk -f </code>，发现分区的目录也挂载好了 ，这样在此目录下的内容就都存放在新建的分区里面了</li></ul></li></ul></li><li><p>设置可以自动挂载</p><ul><li>永久挂载：修改 &#x2F;etc&#x2F;fstab 实现：  <code>vim /etc/fstab</code>  ，按照下面的方式添加信息，保存重启reboot<ul><li>1.方式一：按照原有格式（使用uuid），添加信息</li><li>2.方式二：找到新建的分区的路径也可以，如图：</li><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240905170735027-17255272563417.png" class title="image-20240905170735027"></li></ul></li><li>添加完成后，不重启，则执行<code>mount -a</code> 即可生效</li></ul></li></ol><p> <strong>注意：命令行挂载是临时的，重启失效，采用配置文件的方式是永久的（原理是：开机会读取配置文件）</strong></p><ol start="6"><li>多说一点，卸载分区<ul><li>语法：<ul><li><code>umount 设备名称 </code>   或者  <code>umount 挂载目录</code><ul><li>例如：<code>umount /dev/sdb1   或者   umount /newdisk</code></li></ul></li></ul></li></ul></li></ol><p>理解图：</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240906105827501-17255915093538.png" class title="image-20240906105827501"></blockquote><h3 id="4-磁盘情况查询"><a href="#4-磁盘情况查询" class="headerlink" title="4.磁盘情况查询"></a>4.磁盘情况查询</h3><p>1.查询系统整体磁盘使用情况</p><blockquote><p>df -h</p><p>注意：使用量到达80%，要想办法了</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240906110513050-17255919139819.png" class title="image-20240906110513050"></blockquote><p>2.查询指定目录的磁盘占用情况</p><blockquote><p>du -h  [目录可选]解释：查询指定目录的磁盘占用情况，默认为当前目录</p><ul><li><p>参数</p><ul><li><p>-s 指定自录占用大小汇总·、</p></li><li><p>-h 带计量单位</p></li><li><p>-a 含文件</p></li><li><p>–max-depth&#x3D;1 子目录深度</p></li><li><p>-c 列出明细的同时，增加汇总值</p></li></ul></li></ul><p>案例</p><ul><li><code>du -ha --max-depth=1 /opt</code> 这样更清晰</li><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240906111303426-172559238443710.png" class title="image-20240906111303426"></li></ul></blockquote><p>3.<strong>磁盘实用指令</strong></p><blockquote><p>1.统计&#x2F;opt文件夹下文件的个数</p><p><code>ls -l /opt | grep &quot;^-&quot; | wc -l</code></p><p>2.统计&#x2F;opt文件夹下目录的个数</p><p><code>ls -l /opt | grep &quot;^d&quot; | wc -l</code></p><p>3.统计&#x2F;opt文件夹下文件的个数，包括子文件夹里的</p><p><code>ls -lR /opt | grep &quot;^-&quot; | wc -l</code></p><p>4.统计&#x2F;opt文件夹下目录的个数，包括子文件夹里的</p><p><code>ls -lR /opt | grep &quot;^d&quot; | wc -l</code></p><p>5.以树状显示目录结构 （<strong>注意：</strong>如果没有tree ，则<code>yum install tree</code>）</p><p><code>tree /home/</code></p></blockquote><h2 id="23-网络配置"><a href="#23-网络配置" class="headerlink" title="23.网络配置"></a>23.网络配置</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>1.网络理解图</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240906140332259.png" class title="image-20240906140332259"><p>2.上面的虚拟机ip 192.168.2.x ，为什么前缀是这个</p><blockquote><p>查看vm上方的选项卡—-》虚拟网络编辑器—》点击vm8</p></blockquote><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240906141731604-172560345276611.png" class title="image-20240906141731604"><p>3.查看网络ip和网关</p><blockquote><ul><li>win<ul><li>在cmd中 输入<code>ipconfig</code></li></ul></li><li>linux<ul><li><code>ifconfig</code></li></ul></li></ul></blockquote><p>4.ping 测试网络连接情况</p><blockquote><p>ping ip</p></blockquote><h3 id="linux网络配置"><a href="#linux网络配置" class="headerlink" title="linux网络配置"></a>linux网络配置</h3><blockquote><ul><li><p>第一种方法(自动获取)</p><ul><li>说明:登陆后，通过界面的来设置自动获取ip，特点:linux启动后会自动获取IP,缺点是每次自动获取的ip地址可能不一样。</li></ul></li><li><p>第二种方法(指定ip)</p><ul><li><p>1.说明直接修改配置文件来指定IP，并可以连接到外网(程序员推荐)</p><ul><li>编辑 <code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></li></ul></li><li><p>2.要求:将ip地址配置的静态的，比如:ip地址为192.168.200.130</p><ul><li>ifcfg-ens33 文件说明（下面改的，要改，没有则添加，其余不懂，可能每个电脑文件不一样）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">DEVICE=ets33 #接口名(设备,网卡)<br>HWADDR=00:0C:2x:6x:0x:xx #MAC地址<br>TYPE=Ethernet   #网络光型(通常是Ethemct)<br>UUID=926a57ba-92c6-4231-bacb-f27c5c6a9f44    #随机id<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">系统启动的时候网络接口是否有效(<span class="hljs-built_in">yes</span>/no)-------改<span class="hljs-built_in">yes</span>,</span><br>ONBOOT=yes<br><span class="hljs-meta prompt_">#</span><span class="language-bash">IP的配置方法[none|static|bootp|dhcp] (引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议)---改static</span><br>BOOTPROTO=static<br><span class="hljs-meta prompt_">#</span><span class="language-bash">IP地址----改（没有，写一个ip）</span><br>IPADDR=192.168.200.130<br><span class="hljs-meta prompt_">#</span><span class="language-bash">网关----改（没有，写一个ip）</span><br>GATEWAY=192.168.200.2<br><span class="hljs-meta prompt_">#</span><span class="language-bash">域名解析器----改（没有，写一个ip）</span><br>DNS1=192.168.200.2<br></code></pre></td></tr></table></figure></li><li><p>3.再从vm中打开虚拟网络编辑器</p><ul><li>点击v8网络，修改下面的子网ip：192.168.200.0（因为两边的网段要一致）</li><li>在点击NAT设置，修改里面的网关ip：192.168.200.2 （要和linux系统中的网关一致）</li></ul></li><li><p>4.重启生效，<code>reboot</code>  或   <code>service network restart</code></p></li></ul></li></ul></blockquote><h3 id="设置主机名和hosts映射"><a href="#设置主机名和hosts映射" class="headerlink" title="设置主机名和hosts映射"></a>设置主机名和hosts映射</h3><p>1.设置主机名</p><blockquote><p>1.设置主机名</p><ul><li>为了方便记忆，可以给linux系统设置主机名，也可以根据需要修改主机名</li></ul><p>2.指令: :查看主机名</p><ul><li><code>hostname</code></li></ul><p></p><p>3.修改</p><ul><li>件在&#x2F;etc&#x2F;hostname 指定</li></ul><p>4.修改后，重启生效  <code>reboot</code></p></blockquote><p>2.设置hosts映射</p><blockquote><p><strong>思考:如何通过 主机名能够找到(比如ping)某个linux系统?</strong></p><ul><li><p>windows</p><ul><li>在C:\Windows\System32\drivers\etc\hosts 文件指定即可<ul><li>案例: 192.168.200.130 hspedu100<ul><li>操作：修改hosts文件，添加192.168.200.130 hspedu100</li></ul></li></ul></li></ul></li><li><p>linux</p><ul><li>在&#x2F;etc&#x2F;hosts 文件 指定 <ul><li>案例: 192.168.200.1 ThinkPad-PC<ul><li>操作：<code>vim /etc/hosts</code>添加192.168.200.1 ThinkPad-PC</li></ul></li></ul></li></ul></li></ul></blockquote><h3 id="主机名解析过程分析"><a href="#主机名解析过程分析" class="headerlink" title="主机名解析过程分析"></a>主机名解析过程分析</h3><p>1.概念：</p><blockquote><p>Hosts是什么</p><ul><li>一个文本文件，用来记录IP 和 Hostname(主机名)的映射关系</li></ul><p>DNS</p><ul><li>DNS，就是Domain Name System的缩写，翻译过来就是域名系统</li><li>是互联网上作为域名和IP地址相互映射的一个分布式数据库</li></ul></blockquote><p>2.dns解析过程：浏览器缓存—》电脑DNS缓存—》本地hosts文件—-》网络中DNS域名服务</p><blockquote><p><strong>应用实例:用户在浏览器输入了 <a href="http://www.baidu.com/">www.baidu.com</a></strong></p><p>1.浏览器先检查浏览器缓存中有没有该域名解析IP地址，有就先调用这个IP完成解析;如果没有，就DNS解析器缓存，如果有直接返回IP完成解析。这两个缓存，可以理解为 本地解析器缓存</p><p>2.一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存他的IP地址(DNS解析记录)。如在cmd窗口中输入</p><ul><li><p><code>ipconfig /displaydns</code>&#x2F;&#x2F;DNS域名解析缓存</p></li><li><p><code>ipconfig /flushdns</code>&#x2F;&#x2F;手动清理dns缓存</p></li></ul><p>3.如果本地解析器缓存没有找到对应映射，检查系统中hosts文件中有没有配置对应的域名IP映射，如果有，则完成解析并返回。</p><p>4.如果 本地DNS解析器缓存 和 hosts文件 中均没有找到对应的IP则到域名服务DNS进行解析域</p></blockquote><p>理解图：（这个图少了浏览器缓存，因为可能是通过ping来执行的）</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240906162643789-172561120863012.png" class title="image-20240906162643789"><h2 id="24-进程-ps"><a href="#24-进程-ps" class="headerlink" title="24.进程-ps"></a>24.进程-ps</h2><h3 id="1-基础介绍"><a href="#1-基础介绍" class="headerlink" title="1.基础介绍"></a>1.基础介绍</h3><blockquote><p>在LINUX中，每个执行的程摩都称为一个进程。每一个进程都分配一个ID号(pid,进程号)。&#x3D;&gt;windows &#x3D;&gt;linuX</p><p>2.每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</p><p>3.一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。</p></blockquote><blockquote><p><strong>进程和程序的区别</strong></p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240909094311668.png" class title="image-20240909094311668"></blockquote><h3 id="2-命令-ps"><a href="#2-命令-ps" class="headerlink" title="2.命令-ps"></a>2.命令-ps</h3><blockquote><p>ps    :用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数</p><p>显示的结果：</p><ul><li>pid      进程识别号</li><li>TTY         终端机号</li><li>TIME      此进程所消CPU时间</li><li>CMD      正在执行的命令或进程名</li></ul><p>语法：</p><ul><li>-a  显示当前终端的所有进程信息</li><li>-u  以用户的格式显示进程信息</li><li>-x  显示后台进程运行的参数</li><li>-e  显示所用进程</li><li>-f  全格式</li></ul></blockquote><blockquote><p><code>ps -aux </code>    或 <code>ps -aux | grep sshd</code>   或 <code>ps -ef | grep sshd </code></p><p>显示结果：</p><table><thead><tr><th align="center">标题</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">USER</td><td align="center">用户名称</td></tr><tr><td align="center">PID</td><td align="center">进程号</td></tr><tr><td align="center">%CPU</td><td align="center">进程占用CPU的百分比</td></tr><tr><td align="center">%MEM</td><td align="center">进程占用物理内存的百分比</td></tr><tr><td align="center">VSZ</td><td align="center">进程占用的虚拟内存大小(单位:KB</td></tr><tr><td align="center">RSS</td><td align="center">进程占用的物理内存大小(单位:KB</td></tr><tr><td align="center">TTY</td><td align="center">终端名称,缩写</td></tr><tr><td align="center">STAT</td><td align="center">进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，**Z-僵死进程(程序死了，还在占用内存，需要手动清理)**，T-被跟踪或者被停止等等</td></tr><tr><td align="center">STARTED</td><td align="center">进程的启动时间</td></tr><tr><td align="center">TIME</td><td align="center">CPU时间，即进程使用CPU的总时间</td></tr><tr><td align="center">COMMAND</td><td align="center">启动进程所用的命令和参数，如果过长会被截断显示</td></tr></tbody></table><p>如图：</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240909101036677-172584783882613.png" class title="image-20240909101036677"></blockquote><h3 id="3-应用实例-ps-ef"><a href="#3-应用实例-ps-ef" class="headerlink" title="3.应用实例-ps -ef"></a>3.应用实例-ps -ef</h3><blockquote><p><code>ps -ef </code>以全格式显示当前所有的进程，查看进程的<strong>父进程</strong> </p><p>结果展示：</p><table><thead><tr><th align="center">标题</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">UID</td><td align="center">用户ID</td></tr><tr><td align="center">PID</td><td align="center">进程ID</td></tr><tr><td align="center">PPID</td><td align="center">父进程ID</td></tr><tr><td align="center">C</td><td align="center">CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低数值越小，表明进程是I0密集型运算，执行优先级会提高</td></tr><tr><td align="center">STIME</td><td align="center">进程启动的时间</td></tr><tr><td align="center">TTY</td><td align="center">完整的终端名称</td></tr><tr><td align="center">TIME</td><td align="center">CPU时间</td></tr><tr><td align="center">CMD</td><td align="center">启动进程所用的命令和参数</td></tr></tbody></table></blockquote><h3 id="4-终止进程-kill-killall"><a href="#4-终止进程-kill-killall" class="headerlink" title="4.终止进程-kill killall"></a>4.终止进程-kill killall</h3><blockquote><p>介绍:</p><ul><li>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用ki命令来完成此项任务。</li></ul><p>基本语法</p><ul><li>kill [选项]   进程号    :(功能描述:通过进程号杀死&#x2F;终止进程)</li><li>killall 进程名称   : (功能描述:通过进程名称杀死进程（<strong>包括子进程</strong>），也支持通配符，这在系统因负载过大而变得很慢时很有用)</li></ul><p>常用选项</p><ul><li>-9  表示强迫进程立即停止</li></ul></blockquote><h3 id="5-pstree指令"><a href="#5-pstree指令" class="headerlink" title="5.pstree指令"></a>5.pstree指令</h3><blockquote><p>进程树展示进程之间的关系</p></blockquote><blockquote><p>基本语法</p><ul><li>pstree  [选项]             ::可以更加直观的来看进程信息</li></ul><p>常用选项</p><ul><li>-p显示进程的PID</li><li>-u 显示进程的所属用户</li></ul><p>应用实例:</p><ul><li>案例1:请你树状的形式显示进程的pid</li><li><code>pstree -p</code></li><li>案例2:请你树状的形式进程的用户</li><li><code>pstree -u</code></li></ul></blockquote><h2 id="25-服务管理"><a href="#25-服务管理" class="headerlink" title="25.服务管理"></a>25.服务管理</h2><h3 id="1-服务初步了解"><a href="#1-服务初步了解" class="headerlink" title="1.服务初步了解"></a>1.服务初步了解</h3><blockquote><p>介绍:</p><p>服务(service)本质就是进程但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysqld，sshd 防火墙等)因此我们又称为守护进程，是Linux中非常重要的知识点。[原理图]</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240909123705242-172585662617114.png" class title="image-20240909123705242"><p>service管理指令</p><ul><li>1.<code>service 服务名  [start|stop|restart |reload |status]</code></li><li>2.在CentOS7.0后很多服务不再使用service,而是 systemctl(后面专门讲)</li><li>3.service 指令管理的服务在 &#x2F;etc&#x2F;init.d 查看   (这里可以查看service能管理的服务—》绿色的是服务)<ul><li>方式1：<code>ls -l /etc/init.d</code> <ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240909123914266.png" class title="image-20240909123914266"></li></ul></li><li>方式2：<code>setup</code>   查看所有的服务<ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240909124435381-172585707669215.png" class title="image-20240909124435381"></li></ul></li></ul></li></ul></blockquote><h3 id="2-服务的运行级别-runlevel"><a href="#2-服务的运行级别-runlevel" class="headerlink" title="2.服务的运行级别(runlevel):"></a>2.服务的运行级别(runlevel):</h3><blockquote><p>1.Linux系统有7种运行级别(runlevel):<strong>常用的是级别3和5</strong></p><ul><li>运行级别0:系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li><li>运行级别1:单用户工作状态，root权限，用于系统维护，禁止远程登陆</li><li>运行级别2:多用户状态(没有NFS)，不支持网络</li><li>运行级别3:完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li><li>运行级别4:系统未使用，保留</li><li>运行级别5:X11控制台，登陆后进入图形GUI模式</li><li>运行级别6:系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li></ul><p>2.设置对应级别</p><ul><li><blockquote><p>在centos7以前，&#x2F;etc&#x2F;inittab文件中修改</p><p>centos7以后，进行了简化，如下命令</p><ul><li><strong>multi-user.target:类似于运行级别3</strong></li><li>graphical.target:类似于运行级别5</li></ul></blockquote><p>1.查看当前默认运行级别</p><ul><li><code>systemctl get-default</code></li></ul><p>2.修改默认运行级别  (例子：运行级别5)</p><ul><li><code>systemctl set-default graphical.target</code></li></ul></li></ul><p>3.开机的流程说明</p><p>​开机&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;BIOS&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&#x2F;boot&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;systemd进程1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;运行级别&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;运行级对应的服务</p></blockquote><h3 id="3-设置服务在各个级别中的自-启动-关闭-chkconfig指令"><a href="#3-设置服务在各个级别中的自-启动-关闭-chkconfig指令" class="headerlink" title="3.设置服务在各个级别中的自 启动&#x2F;关闭-chkconfig指令"></a>3.设置服务在各个级别中的自 启动&#x2F;关闭-chkconfig指令</h3><p>1.chkconfig指令  ，一个服务在不同的启动级别，自启动是不同的</p><blockquote><p>介绍</p><ul><li>通过chkconfig 命令可以给服务的各个运行级别设置自 启动&#x2F;关闭</li><li>chkconfig 指令管理的服务在 &#x2F;etc&#x2F;init.d 查看</li><li>注意:Centos7.0后，很多服务使图aystemctl管理(后面马上讲)</li></ul><p>chkconfig基本语法</p><ul><li>查看服务 chkconfig –list [| grep xxx]   #查看各个级别，服务的情况</li><li>chkconfig 服务名 –list       #查看某个服务在各个级别的情况</li><li>chkconfig –level 5 服务名 on&#x2F;off      #设置某个服务在某个级别是自启动&#x2F;关闭</li></ul><p>案例演示:对network服务 进行各种操作：：把network 在3运行级别,关闭自启动</p><ul><li><p><code>chkconfig --level 3 network off</code>     #3级别关闭</p></li><li><p><code>chkconfig --level 3 network on </code>     #3级别打开</p></li></ul><blockquote><p>**使用细节:**chkconfig重新设置服务后自启动或关闭，需要重启机器reboot生效</p></blockquote></blockquote><h3 id="4-systemctl的使用"><a href="#4-systemctl的使用" class="headerlink" title="4.systemctl的使用"></a>4.systemctl的使用</h3><p>systemctl管理指令</p><blockquote><p>1.基本语法:</p><ul><li><p><code>systemctl [start | stop | restart | status] 服务名</code></p></li><li><p>systemctl指令管理的服务在<code>/usr/lib/systemd/system</code> 查看</p></li></ul><p>2.systemctl设置服务的自启动状态 (Centos7以后，默认是3和5)</p><ul><li><p><code>systemctl list-unit-files [| grep 服务名] </code>(查看服务开机启动状态,grep 可以进行过滤)</p></li><li><p><code>systemctl enable 服务名</code>     (设置服务开机启动)</p></li><li><p><code>systemctl disable 服务名 </code>    (关团服务开机启动)</p></li><li><p><code>systemctl is-enabled 服务名</code>    (查询某个服务是否是自启动的)</p></li></ul><p>3.应用案例:</p><ul><li>查看当前防火墙的状况，关闭防火墙和重启防火墙。<ul><li><code>systemctl status firewall</code></li><li><code>systemctl stop firewall</code></li><li><code>systemctl start firewall</code></li></ul></li></ul><p>4.细节讨论:</p><ul><li>1.关闭或者启用防火墙后，会立即生效。[teInet 测试 某个端口即可]</li><li>2.<strong>案例这种方式只是临时生效</strong>，当重启系统后，还是回归以前对服务的设置。</li><li>3.如果希望<strong>设置某个服务自启动或关闭永久生效</strong>，要使用 <code>systemctl [enable|disable] 服务名</code>。</li></ul><p>5.telnet的使用</p><ul><li>在win系统中的cmd里执行telnet测试某个服务的端口能不能连接<ul><li><code>telnet ip 端口</code></li></ul></li></ul><p>6.看看网络状态-netstat</p><ul><li><code>netstat -anp </code></li></ul></blockquote><h3 id="5-防火墙"><a href="#5-防火墙" class="headerlink" title="5.防火墙"></a>5.防火墙</h3><blockquote><p>1.防火墙打开或者关闭指定端口</p><blockquote><p>在真正的生产环境，往往需要将防火墙打开，但问题来了，，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。比如80、22、8080等，这个又怎么做呢?老韩给给大家讲一讲。</p><p>理解图：</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240909160229620.png" class title="image-20240909160229620"></blockquote><p>2.firewall指令</p><ul><li>打开端口:<code>firewall-cmd --permanent --add-port=端囗号/协议</code></li><li>关团端口:<code>firewall-cmd --permanent --remove-port=端囗号/协议</code></li><li>重新载入,才能生效:<code>firewall-cmd --reload</code></li><li>查询端口是否开放:<code>firewall-cmd --query-port=端口/协议</code></li><li>查看已经开放的端囗号：<code>firewall-cmd --zone=public --list-ports</code></li></ul><p>3.怎么知道端口的协议是什么协议呢  #下面命令第一列就是协议</p><ul><li><code>netstat -anp</code></li></ul><p>4.应用案例:</p><ul><li>启用防火墙，测试 111端口是否能 telnet</li><li>开放111端口，下面都要执行<ul><li><code>firewall-cmd --permanent --add-port=111/tcp</code></li><li><code>firewall-cmd --reload</code></li></ul></li><li>再次关闭111端口<ul><li><code>firewall-cmd --permanent --remove-port=111/tcp</code></li><li><code>firewall-cmd --reload</code></li></ul></li></ul></blockquote><h2 id="26-动态监控进程-top"><a href="#26-动态监控进程-top" class="headerlink" title="26.动态监控进程-top"></a>26.动态监控进程-top</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍:"></a>1.介绍:</h3><blockquote><p>介绍:</p><blockquote><p>top与ps命令很相似。它们都用来显示正在执行的进程。Top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程。</p></blockquote><p>基本语法</p><ul><li>top [选项]</li></ul><p>选项说明</p><ul><li><table><thead><tr><th align="center">选项</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-d 秒数</td><td align="center">指定top命令每隔几秒更新。默认是3秒    例如top -d 5  #每5s刷新一次</td></tr><tr><td align="center">-i</td><td align="center">使top不显示任何闲置或者死进程</td></tr><tr><td align="center">-p</td><td align="center">通过指定监控进程ID来仅仅监控某个进程的状态。</td></tr></tbody></table></li></ul><p>结果讲解：</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240909142927058-172586336876816.png" class title="image-20240909142927058"></blockquote><h3 id="2-交换操作-top"><a href="#2-交换操作-top" class="headerlink" title="2.交换操作-top"></a>2.交换操作-top</h3><blockquote><p>交互操作说明:</p><table><thead><tr><th align="center">操作</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">P</td><td align="center">以CPU使用率排序，默认就是此项</td></tr><tr><td align="center">M</td><td align="center">以内存的使用率排序</td></tr><tr><td align="center">N</td><td align="center">以PID排序</td></tr><tr><td align="center">q</td><td align="center">退出top</td></tr></tbody></table><p>应用实例</p><ul><li><p>案例1.监视特定用户</p><ul><li><p>1.输入<code>top</code>命令，按回车键，查看执行的进程</p></li><li><p>2.然后输入“u”回车，再输入用户名，即可</p></li></ul></li><li><p>案例2:终止指定的进程。</p><ul><li>1.输入<code>top</code>命令，按回车键，查看执行的进程。</li><li>2.然后输入<code>k</code>回车，再输入要结束的进程ID号，若要求输入信号量则输入 <code>9</code>   (9为强制杀死进程)</li></ul></li><li><p>案例3:指定系统状态更新的时间(每隔10秒自动更新)</p><ul><li><code>top -d 10</code></li></ul></li></ul></blockquote><h2 id="27-监控网络状态-netstat"><a href="#27-监控网络状态-netstat" class="headerlink" title="27.监控网络状态-netstat"></a>27.监控网络状态-netstat</h2><p>查看系统网络情况netstat</p><blockquote><p>1.基本语法</p><p><code>netstat [选顶]</code></p><p>2.选项说明</p><ul><li><p>-an   按一定顺序排列输出</p></li><li><p>-p    显示哪个进程在调用 (会显示进程id和名称)</p></li></ul><p>3.应用案例</p><ul><li>请查看服务名为 sshd 的服务的信息。<ul><li><code>netstat -anp | grep sshd</code></li></ul></li></ul><p>4.检测主机连接命令</p><ul><li>ping:是-种网络检测工具，它主要是用检测远程主机是否正常，或是两部主机间的网线或网卡故障。如: ping 对方ip地址<ul><li>ping <a href="http://www.baidu.com/">www.baidu.com</a></li></ul></li></ul><p>5.结果说明：</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240909152837908-172586691964017.png" class title="image-20240909152837908"></blockquote><h2 id="28-rpm管理"><a href="#28-rpm管理" class="headerlink" title="28.rpm管理"></a>28.rpm管理</h2><h3 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1.介绍"></a>1.介绍</h3><blockquote><p>介绍</p><blockquote><p>rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager(RedHat软件包管理工具)的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的</p></blockquote><blockquote><p>Linux的分发版本都有采用(suse,redhat,centos 等等)，可以算是公认的行业标准了</p></blockquote></blockquote><h3 id="2-rpm包的简单查询指令"><a href="#2-rpm包的简单查询指令" class="headerlink" title="2.rpm包的简单查询指令"></a>2.rpm包的简单查询指令</h3><blockquote><p>1.rpm包的简单查询指令</p><ul><li>查询已安装的rpm列表 <ul><li><code>rpm -qa |  grep xx</code></li></ul></li></ul><p>2.举例:看看当前系统，是否安装了firefox</p><ul><li><code>rpm -qa |  grep firefox</code></li></ul><p>3.rpm包名基本格式</p><ul><li><p>一个rpm包名:   firefox-60.2.2-1.el7.centos.x86 64，如下解释</p><ul><li><p>名称:firefox</p></li><li><p>版本号:60.2.2-1</p></li></ul></li><li><p>适用操作系统:el7.centos.x86 64</p><ul><li><p>表示centos7.x的64位系统</p></li><li><p>如果是i686、i386表示32位系统，noarch表示通用</p></li></ul></li></ul></blockquote><h3 id="3-rpm包的其他查询指令："><a href="#3-rpm包的其他查询指令：" class="headerlink" title="3.rpm包的其他查询指令："></a>3.rpm包的其他查询指令：</h3><blockquote><p>1.rpm包的其它查询指令:</p><ul><li><p><code>rpm -qa</code> :查询所安装的所有rpm软件包</p></li><li><p><code>rpm -qa | more</code></p></li><li><p><code>rpm -qa | grep X </code>     :比如：<code>rpm -qa | grep firefox </code></p></li></ul><p>2.<code>rpm -q 软件包名 </code>    :查询软件包是否安装</p><ul><li>案例:   <code>rpm -q firefox</code></li></ul><p>3.<code>rpm -qi 软件包名</code>   :查询软件包信息</p><ul><li>案例: <code>rpm -qi firefox </code></li></ul><p>4.<code>rpm -ql 软件包名</code>     :查询软件包中的文件</p><ul><li>比如:<code>rpm -ql firefox</code></li></ul><p><code>rpm -qf 文件全路径名 </code>     查询文件所属的软件包</p><ul><li><p><code>rpm -qf /etc/passwd</code></p></li><li><p><code>rpm -qf /root/install.log</code></p></li></ul></blockquote><h3 id="4-卸载rpm包"><a href="#4-卸载rpm包" class="headerlink" title="4.卸载rpm包"></a>4.卸载rpm包</h3><p>卸载rpm包</p><blockquote><p>1.基本语法</p><ul><li>rpm -e RPM包的名称 &#x2F;&#x2F;erase</li></ul><p>2.应用案例</p><ul><li>删除firefox 软件包(不用写很全的名称，包的开头就行，但包名要写清楚)<ul><li><code>rpm -e firefox</code></li></ul></li></ul><p>3.细节讨论</p><ul><li><p>1.如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息</p><ul><li><p>如：<code>rpm -e foo</code></p><ul><li><blockquote><p>removing these packages would break dependencies:foo is needed by bar-1.0-1</p></blockquote></li></ul></li></ul></li><li><p>2.如果我们就是要删除 foo这个rpm 包，可以增加参数 –nodeps,就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行</p><ul><li>如: <code>rpm -e --nodeps foo</code></li></ul></li></ul></blockquote><h3 id="5-安装rpm"><a href="#5-安装rpm" class="headerlink" title="5.安装rpm"></a>5.安装rpm</h3><p>安装rpm包</p><blockquote><p>1.基本语法</p><ul><li><code>rpm -ivh RPM包全路径名称</code></li></ul><p>2.参数说明</p><ul><li><p>i&#x3D;install 安装</p></li><li><p>v&#x3D;verbose 提示</p></li><li><p>h&#x3D;hash 进度条</p></li></ul></blockquote><h2 id="29-yum"><a href="#29-yum" class="headerlink" title="29.yum"></a>29.yum</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>1.介绍:</p><blockquote><p>Yum 是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以<strong>自动处理依赖性关系</strong>，并且一次安装所有依赖的软件包</p><ul><li>原理图<ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240909165101473.png" class title="image-20240909165101473"></li></ul></li></ul></blockquote><p>2.yum的基本指令</p><ul><li><p>1.查询yum服务器是否有需要安装的软件</p><ul><li><code>yum list | grep xx</code>  #软件列表</li></ul></li><li><p>2.安装指定的yum包</p><ul><li><code>yum install xxx </code>   #下载安装</li></ul></li></ul><p>3.yum应用实例</p><ul><li>案例:请使用yum的方式来安装firefox<ul><li><code>rpm -e firefox</code>     #先删除已有的firefox</li><li><code>rpm list | grep firefox </code>    #查看yum服务上有那些firefox</li><li><code>yum install firefox</code>    #下载安装想要的版本</li></ul></li></ul></blockquote><h1 id="安装java环境"><a href="#安装java环境" class="headerlink" title="安装java环境"></a>安装java环境</h1><h3 id="1-jdk"><a href="#1-jdk" class="headerlink" title="1.jdk"></a>1.jdk</h3><blockquote><p>1.<code>mkdir /opt/jdk</code></p><p>2.将jdk包通过xftp6 上传到 &#x2F;opt&#x2F;jdk下</p><p>3.<code>cd /opt/jdk</code></p><p>4.解压 <code>tar -zxvf jdk-8u261-linux-x64.tar.gz</code></p><p>5.<code>mkdir /usr/local/java</code></p><p>6.<code>mv /opt/jdk/jdk1.8.0_261 /usr/local/java</code></p><p>7.配置环境变量的配置文件  <code>vim /etc/profile</code></p><p>8.再配置文件的最后面输入下面内容</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/local/java/jdk1.8.0 261<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$JAVA_HOME</span>/bin:$PATH<br></code></pre></td></tr></table></figure><p>9.<code>source /etc/profile</code>  [让新的环境变量生效]</p></blockquote><h3 id="2-tomcat8"><a href="#2-tomcat8" class="headerlink" title="2.tomcat8"></a>2.tomcat8</h3><h3 id="3-idea2020"><a href="#3-idea2020" class="headerlink" title="3.idea2020"></a>3.idea2020</h3><h3 id="4-mysql5-7"><a href="#4-mysql5-7" class="headerlink" title="4.mysql5.7"></a>4.mysql5.7</h3><blockquote><p><strong>注：centos7.6自带的类mysql数据库是mariadb，会跟 mysql冲突，要先删除</strong></p><ul><li><code>rpm -qa | grep mari</code></li><li><code>rpm -e --nodeps mariadb-libs</code></li></ul></blockquote><h1 id="大数据-shell编程"><a href="#大数据-shell编程" class="headerlink" title="大数据-shell编程"></a>大数据-shell编程</h1><h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h2><blockquote><p>shell是什么</p><blockquote><p>Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序用户可以用Shell来启动、挂起、停止甚至是编写一些程序。看一个示意图</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240910142303731.png" class title="image-20240910142303731"></blockquote></blockquote><blockquote><p>Shell脚本的执行方式</p><p>1.脚本格式要求</p><ul><li>脚本以#!&#x2F;bin&#x2F;bash开头</li><li>脚本需要有可执行权限</li></ul><p>2.编写第一个Shell脚本</p><ul><li><p>需求说明:创建一个Shell脚本，输出hello world!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;hello,world~&quot;<br></code></pre></td></tr></table></figure></li></ul><p>3.脚本的常用执行方式</p><ul><li><p>方式1(输入脚本的绝对路径或相对路径)</p><ul><li>说明:首先要赋予helloworld.sh 脚本的+x权限(<code>chmod u+x xxx.sh</code>)，再执行脚本。如：<code>./xxx.sh</code>  或  <code>/root/shcode/xxx.sh</code></li></ul></li><li><p>方式2(sh+脚本)说明:不用赋予脚本+x权限，直接执行即可。如：<code>sh xxx.sh</code></p></li></ul></blockquote><h2 id="2-Shell-变量"><a href="#2-Shell-变量" class="headerlink" title="2.Shell 变量"></a>2.Shell 变量</h2><p>1.Shell变量</p><blockquote><p>1.Shell变量</p><ul><li><p>介绍Linux Shell中的变量分为，系统变量和用户自定义变量</p></li><li><p>系统变量:<code>$HOME、$PWD、$SHELL、$USER</code>等等，比如:<code>echo $HOME </code>等等</p></li><li><p>显示当前shell中所有变量:<code>set</code></p></li></ul><p>2.shell变量的定义</p><ul><li><p>基本语法</p><ul><li><p>定义变量:变量&#x3D;值</p></li><li><p>撤销变量:<code>unset 变量</code>.</p></li><li><p>声明静态变量:<code>readonly 变量 </code>，注意：不能<code>unset</code></p></li></ul></li><li><p>快速入门</p><ul><li><p>案例1:定义变量A</p></li><li><p>案例2:撤销变量A</p></li><li><p>案例3:声明静态的变量B&#x3D;2，不能unset</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">案例一</span><br>A=100<br>echo A=$A<br><span class="hljs-meta prompt_">#</span><span class="language-bash">案例二</span><br>unset A<br>echo A=$A<br><span class="hljs-meta prompt_">#</span><span class="language-bash">案例三</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">不能<span class="hljs-built_in">unset</span> B</span><br>readonly B=2<br><br></code></pre></td></tr></table></figure></li><li><p>案例4:可把变量提升为全局环境变量，可供其他shel程序使用[该案例后面讲]</p></li></ul></li></ul></blockquote><p>2.shell变量的定义</p><blockquote><p>1.定义变量的规则</p><ul><li><p>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。5A&#x3D;200(x)</p></li><li><p>等号两侧不能有空格</p></li><li><p>变量名称一般习惯为大写</p></li></ul><p>2.将<strong>命令</strong>的返回值赋给变量</p><ul><li><p>A&#x3D;`date`反引号，运行里面的命令，并把结果返回给变量A</p></li><li><p>A&#x3D;$(date)等价于反引号</p></li></ul></blockquote><h2 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3.设置环境变量"></a>3.设置环境变量</h2><p>入门</p><blockquote><p>1.基本语法</p><ul><li><p>1.export 变量名&#x3D;变量值   (功能描述:将shell变量输出为环境变量&#x2F;全局变量)</p></li><li><p>2.source 配置文件   (功能描述:让修改后的配置信息立即生效)</p></li><li><p>3.echo $变量名    (功能描述:查询环境变量的值)</p></li></ul><p>2.快速入门</p><ul><li><p>1.在<code>/etc/profile</code>文件中定义TOMCAT_HOME环境变量</p></li><li><p>2.查看环境变量TOMCAT HOME的值</p></li><li><p>3.在另外一个shell程序中使用 TOMCAT_HOME</p></li></ul><p>注意:在输出TOMCAT_HOME 环境变量前，需要让其生效</p><p><code>source /etc/profile</code></p><p>3.为什么设置环境变量（看图）</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240910145933992.png" class title="image-20240910145933992"><p>4.注释</p><ul><li><p>单行注释：<code>#</code></p></li><li><p>多行注释：<code>:&lt;&lt;!</code>  <code>!</code> 必须单独一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;!<br>内容~<br>!<br></code></pre></td></tr></table></figure></li></ul></blockquote><h2 id="4-位置参数变量"><a href="#4-位置参数变量" class="headerlink" title="4.位置参数变量"></a>4.位置参数变量</h2><blockquote><p>1.介绍</p><blockquote><p>当我们执行一个shel脚本时，如果希望获取到命令行的参数信息，就可以使用到<strong>位置参数变量</strong></p><p>比如 :<code>./myshell.sh 100 200</code>,这个就是一个执行shell的命令行，可以在myshell 脚本中获取到参数信息</p></blockquote><p>2.基本语法</p><ul><li><p><code>$n</code> (功能描述:n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10})</p></li><li><p><code>$*</code>(功能描述:这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体,所以循环的时候是一次)</p></li><li><p><code>$@</code>(功能描述:这个变量也代表命令行中所有的参数，不过<code>$@</code>把每个参数区分对待，这里是有多少循环多少)</p></li><li><p><code>$#</code>(功能描述:这个变量代表命令行中所有参数的个数)</p></li></ul><p>3.位置参数变量</p><p>案例:编写一个shell脚本 position.sh ，在脚本中获取到命令行的各个参数信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>echo &quot;0=$0 1=$1 2=$2&quot;<br>echo &quot;所有参数=$*&quot;<br>echo &quot;$@&quot;<br>echo &quot;参数的个数=$#&quot;<br></code></pre></td></tr></table></figure></blockquote><h2 id="5-预定义变量"><a href="#5-预定义变量" class="headerlink" title="5.预定义变量"></a>5.预定义变量</h2><p>介绍（用的不多）</p><blockquote><p>1.基本介绍</p><blockquote><p>就是shell设计者事先已经定义好的变量，可以直接在shel脚本中使用</p></blockquote><p>2.基本语法</p><ul><li><p><code>$$</code>   (功能描述:当前进程的进程号(PID))</p></li><li><p><code>$!</code>    (功能描述:后台运行的最后一个进程的进程号(PID))</p></li><li><p><code>$?</code>    (功能描述:最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行如果这个变量的值为非0(具体是哪个数，由命令自己来决定)，则证明上一个命令执行不正确了。)</p></li></ul><p>3.应用实例</p><ul><li>在一个shell脚本中简单使用一下预定义变量</li><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240910155833833.png" class title="image-20240910155833833"></li></ul></blockquote><h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6.运算符"></a>6.运算符</h2><blockquote><p>1.基本介绍</p><blockquote><p>学习如何在shel中进行各种运算操作。</p></blockquote><p>2.基本语法</p><ul><li><p>1.<code>$((运算式))</code>或<code>$[运算式]</code>或者 <code>expr m + n </code>        #其中expr是expression这个单词的缩写，中文是表达式的意思</p><ul><li>注意expr运算符间要有空格，如果希望将 expr 的结果赋给某个变量，使用``</li></ul></li><li><p>3.<code>expr m - n</code></p></li><li><p>4.<code>expr</code>  <code>\*</code>，<code>/</code>，<code>% </code>      #分别是&#x3D;&#x3D;》<strong>乘</strong>（要注意），除，取余</p></li></ul><p>3.应用实例</p><ul><li>案例1:计算(2+3*4的值</li><li>案例2:请求出命令行的两个参数[整数]的和<ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240910161209247.png" class title="image-20240910161209247"></li></ul></li></ul></blockquote><h2 id="7-条件判断"><a href="#7-条件判断" class="headerlink" title="7.条件判断"></a>7.条件判断</h2><p>1.判断语句</p><blockquote><p>1.基本语法</p><ul><li><code>[ condition ]</code>(注意condition前后要有空格)  <ul><li>#condition 为你输入的条件，非空返回true，可使用$?验证(0为true，&gt;1为false)</li></ul></li></ul><p>应用实例</p><ul><li>[ hspEdu ]    这个条件返回true</li><li>[ ]这个条件返回false</li><li><code>[ condition  ] &amp;&amp; echo OK || echo notok</code>    条件满足，执行后面的语句<ul><li>例如：确保备份目录存在,创建备份目录，如果不存在，就创建<code>[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;</code></li></ul></li></ul></blockquote><p>2.条件判断</p><blockquote><p>1.判断语句常用判断条件</p><ul><li><p>1.&#x3D; 字符串比较</p></li><li><p>2.两个整数的比较</p><ul><li>-lt 小于</li><li>-le 小于等于    # little equal的简写</li><li>-eq 等于-gt 大于</li><li>-ge 大于等于</li><li>-ne 不等于</li></ul></li><li><p>3.按照文件权限进行判断</p><ul><li>-r 有读的权限</li><li>-w 有写的权限</li><li>-x 有执行的权限</li></ul></li><li><p>4.按照文件类型进行判断</p><ul><li>-f  文件存在并且是一个常规的文件</li><li>-e  文件存在</li><li>-d  文件存在并是一个目录</li></ul></li></ul><p>2.应用实例</p><ul><li>案例1:”@k”是否等于”ok”<ul><li>判断语句:  使用 <code>=</code></li></ul></li><li>案例2:23是否大于等于22<ul><li>判断语句: 使用 <code>-ge</code></li></ul></li><li>案例3:&#x2F;root&#x2F;shcode&#x2F;aaa.txt目录中的文件是否存在<ul><li>判断语句: 使用 <code>-f</code></li></ul></li><li>上面案例的结果<ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240910163042552.png" class title="image-20240910163042552"></li></ul></li></ul></blockquote><h2 id="8-单分支多分支"><a href="#8-单分支多分支" class="headerlink" title="8.单分支多分支"></a>8.单分支多分支</h2><p>1.流程控制</p><blockquote><p>1.if 判断  基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ]<br>then<br>程序<br>fi<br></code></pre></td></tr></table></figure><p>或多分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件判断式 ]<br>then<br>程序<br>elif [ 条件判断式 ]<br>then<br>程序<br>fi<br></code></pre></td></tr></table></figure><p>2.注意事项:</p><ul><li><p>(1)[条件判断式]，中括号和条件判断式之间必须有空格</p></li><li><p>(2)推荐使用第二种方式</p></li></ul><p>3.应用实例</p><ul><li>案例:请编写-一个shell程序，如果输入的参数，大于等于60，则输出”及格了”,如果小于60,则输出不及格<ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240910164143965.png" class title="image-20240910164143965"></li></ul></li></ul></blockquote><h2 id="9-case语句"><a href="#9-case语句" class="headerlink" title="9.case语句"></a>9.case语句</h2><blockquote><p>case语句是基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量名 in<br>&quot;值1”)<br>如果变量的值等于值1，则执行程序1<br>;;<br>&quot;值2”)<br>如果变量的值等于值2，则执行程序2<br>;;<br>*)<br>如果变量的值都不是以上的值，则执行此程序<br>;;<br>esac<br></code></pre></td></tr></table></figure><p>应用实例 testCase.sh</p><ul><li>案例1 :当命令行参数是 1 时，输出”周一”,是2 时，就输出”周二”，其它情况输出“other”<ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240910164808477.png" class title="image-20240910164808477"></li></ul></li></ul></blockquote><h2 id="10-for循环"><a href="#10-for循环" class="headerlink" title="10.for循环"></a>10.for循环</h2><p>for循环</p><blockquote><p>1.基本语法1，这个是一些具体值循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for 变量 in 值1 值2 值3..<br>do<br>程序<br>done<br></code></pre></td></tr></table></figure><p>2.应用实例 </p><ul><li>案例1:打印命令行输入的参数  [<strong>这里可以看出<code>$* </code>和<code>$@</code>的区别</strong>]<ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240910165433283.png" class title="image-20240910165433283"></li></ul></li></ul><p>3.基本语法2，条件是一个范围</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for((初始值;循环控制条件;变量变化 ))<br>do<br>程序<br>done<br></code></pre></td></tr></table></figure><p>4.应用实例 </p><ul><li>案例1:从1加到100的值输出显示<ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240910165853874.png" class title="image-20240910165853874"></li></ul></li></ul></blockquote><h2 id="11-while循环"><a href="#11-while循环" class="headerlink" title="11.while循环"></a>11.while循环</h2><blockquote><p>while循环<br>基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ 条件判断式 ]do<br>程序<br>done<br></code></pre></td></tr></table></figure><ul><li>注意：<code>while</code>和<code>[</code>有空格，条件判断式和<code>[</code>也有空格</li></ul><p>应用实例</p><ul><li><p>案例1 :从命令行输入一个数n，统计从 1+..+n 的值是多少?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>SUM=0<br>i=0<br>while [ $i -le $1 ]<br>do<br>SUM=$[$SUM+$I]<br>i=$[$i+1]<br>done<br>echo &quot;执行结束=$SUM&quot;<br></code></pre></td></tr></table></figure></li></ul></blockquote><h2 id="12-read获取输入"><a href="#12-read获取输入" class="headerlink" title="12.read获取输入"></a>12.read获取输入</h2><blockquote><p>read读取控制台输入</p></blockquote><blockquote><p>1.基本语法</p><ul><li>read(选项)(参数)</li></ul><p>2.选项:</p><ul><li>-p:指定读取值时的提示的内容;</li><li>-t:指定读取值时等待的时间(秒)，如果没有在指定的时间内输入，就不再等待了</li></ul><p>3.参数</p><ul><li>变量:指定读取值的变量名</li></ul><p>4.应用实例</p><ul><li>案例1:读取控制台输入一个num值</li><li>案例2:读取控制台输入一个num值，在10秒内输入。<ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240911095034654.png" class title="image-20240911095034654"></li></ul></li></ul></blockquote><h2 id="13-系统函数"><a href="#13-系统函数" class="headerlink" title="13.系统函数"></a>13.系统函数</h2><p>函数介绍</p><blockquote><p>1.介绍</p><blockquote><p>shell编程和其它编程语言一样，有系统函数，也可以自定义函数。系统函数中，我们这里就介绍两个。</p></blockquote><p>2.系统函数(可以用到shell脚本中)</p><ul><li><p>basename基本语法</p><ul><li><p>功能:返回完整路径最后&#x2F;的部分，<strong>常用于获取文件名</strong></p></li><li><p><code>basename  [pathname] [suffix]</code></p></li><li><p><code>basename [string] [suffix]</code></p><ul><li>(功能描述:basename命令会删掉所有的前缀包括最后个(‘&#x2F;’)字符，然后将字符串显示出来。</li></ul></li></ul></li></ul><p>3.选项:</p><ul><li><p>pathname&#x2F;string，为我们想要处理的路径&#x2F;字符串</p></li><li><p>suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉</p></li></ul><p>4.应用实例</p><blockquote><p>案例1:请返回 &#x2F;home&#x2F;aaa&#x2F;test.txt 的”test.txt”部分</p></blockquote><ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240911100007185.png" class title="image-20240911100007185"></li></ul></blockquote><blockquote><p>dirname基本语法</p><p>功能:返回完整路径最后&#x2F;的前面的部分，<strong>常用于返回路径部分</strong></p><p>dirname 文件绝对路径(功能描述:从给定的包含绝对路径的文件名中去除文件名(非目录的部分)，然后返回剩下的路径(目录的部分))</p><p>应用实例</p><p>案例1:请返回&#x2F;home&#x2F;aaa&#x2F;test.txt的&#x2F;home&#x2F;aaa</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240911100249291.png" class title="image-20240911100249291"></blockquote><h2 id="14-自定义函数"><a href="#14-自定义函数" class="headerlink" title="14.自定义函数"></a>14.自定义函数</h2><blockquote><p>1.自定义函数基本语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ function ] funname[0]<br>&#123;<br>程序;<br>[return int;]<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">调用直接写函数名:funname [值]</span><br></code></pre></td></tr></table></figure><p>2.应用实例</p><ul><li>案例1:计算输入两个参数的和，getsum</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">function getsum()<br>&#123;<br>SUM=$[$n1+$n2];<br>echo &quot;和是=$SUM&quot;<br>&#125;<br><br>read -p ”请输入一个数 n1=“ n1<br>read -p ”请输入一个数 n2=“ n2<br><span class="hljs-meta prompt_">#</span><span class="language-bash">调用</span><br>getSUM $n1 $n2<br></code></pre></td></tr></table></figure><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240911102511054.png" class title="image-20240911102511054"></blockquote><h2 id="15-写一个定时备份数据库脚本"><a href="#15-写一个定时备份数据库脚本" class="headerlink" title="15.写一个定时备份数据库脚本"></a>15.写一个定时备份数据库脚本</h2><blockquote><p>1.需求分析</p><ul><li><p>1.每天凌晨 2:30 备份 数据库 hspEduDB到 &#x2F;data&#x2F;backup&#x2F;db</p></li><li><p>2.备份开始和备份结束能够给出相应的提示信息</p></li><li><p>3.备份后的文件要求以备份时间为文件名，并打包成.tar.gz的形式，比如:2021-03-12 230201.tar.gz</p></li><li><p>4.在备份的同时，检查是否有10天前备份的数据库文件，如果有就将其删除。</p></li></ul><p>2.思路分析图</p><ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240911103014606.png" class title="image-20240911103014606"></li><li><p>将脚本放到<code>/usr/sbin</code>目录下，因为这个目录是root执行的权限，而任务调度也是root用户，所以放到这个目录中</p><ul><li><p>1.脚本如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份目录</span><br>BACKUP=/data/backup/db<br><span class="hljs-meta prompt_">#</span><span class="language-bash">当前时间</span><br>DATETIME=$(date +%Y-%m-%d_%H%M%S)<br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库地址</span><br>HOST=localhost<br>      #数据库用户名<br>DB_USER=root<br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库密码</span><br>DB_PW=123456<br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份的数据库名</span><br>DATABASE=test<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建备份目录，如果不存在，就创建</span><br>[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份数据库(这里有风险，数据库密码泄露)</span><br>mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PW&#125; --host=$&#123;HOST&#125; -q -R --databases $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$DATETIME.sql.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将文件处理成 tar.gz</span><br>cd $&#123;BACKUP&#125;<br>      tar -zcvf $DATETIME.tar.gz $&#123;DATETIME&#125;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除对应的备份目录</span><br>rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除10天前的备份文件</span><br>find $&#123;BACKUP&#125; -mtime +10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;<br>echo &quot;$&#123;DATETIME&#125;===开始备份数据库===$&#123;DATABASE&#125;====成功&quot;<br></code></pre></td></tr></table></figure><ul><li>2.设置循环执行命令</li></ul></li><li><p>crontab -e </p></li><li><p><code>30 2 * * * /usr/sbin/mysql_db_backup.sh</code></p></li></ul></li></ul></blockquote><p>脚本参考：</p><blockquote><p>多了每次的日志信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份目录</span><br>BACKUP=/data/backup/db<br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志文件</span><br>LOGFILE=$&#123;BACKUP&#125;/backup.log<br><span class="hljs-meta prompt_">#</span><span class="language-bash">当前时间</span><br>DATETIME=$(date +%Y-%m-%d_%H%M%S)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库地址</span><br>HOST=localhost<br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库用户名</span><br>DB_USER=root<br><span class="hljs-meta prompt_">#</span><span class="language-bash">数据库密码</span><br>DB_PW=123456<br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份的数据库名</span><br>DATABASE=mydatebase<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">创建备份目录，如果不存在，就创建</span><br>[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将所有输出（包括错误信息）记录到日志文件中</span><br>exec &gt; &gt;(tee -a $&#123;LOGFILE&#125;) 2&gt;&amp;1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">备份数据库(这里有风险，数据库密码泄露)</span><br>mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PW&#125; --host=$&#123;HOST&#125; -q -R --databases $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$DATETIME.sql.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将文件处理成 tar.gz</span><br>cd $&#123;BACKUP&#125;<br>tar -zcvf $DATETIME.tar.gz $&#123;DATETIME&#125;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除对应的备份目录</span><br>rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除10天前的备份文件</span><br>find $&#123;BACKUP&#125; -mtime +10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;<br>echo &quot;$&#123;DATETIME&#125;===开始备份数据库===$&#123;DATABASE&#125;====成功&quot;<br></code></pre></td></tr></table></figure><p>脚本2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置部分</span><br>BACKUP_DIR=&quot;/data/backup/db&quot;<br>LOG_FILE=&quot;$&#123;BACKUP_DIR&#125;/backup.log&quot;<br>DATETIME=$(date +%Y-%m-%d_%H%M%S)<br>HOST=&quot;localhost&quot;<br>DB_USER=&quot;root&quot;<br>DB_PW_FILE=&quot;/opt/db_password_file&quot; # 需要确保该文件权限安全,存放密码的地方<br>DATABASE=&quot;mydatabase&quot;<br>RETENTION_DAYS=10<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确保备份目录存在,创建备份目录，如果不存在，就创建</span><br>[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将所有输出（包括错误信息）记录到日志文件中</span><br>exec &gt; &gt;(tee -a &quot;$&#123;LOG_FILE&#125;&quot;) 2&gt;&amp;1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查密码文件是否存在</span><br>if [ -f &quot;$&#123;DB_PW_FILE&#125;&quot; ]; then<br>    DB_PW=$(cat &quot;$&#123;DB_PW_FILE&#125;&quot;)<br>else<br>    DB_PW=&quot;&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">备份数据库</span><br>echo &quot;$&#123;DATETIME&#125; - 开始备份数据库 $&#123;DATABASE&#125;...&quot;<br>if [ -z &quot;$&#123;DB_PW&#125;&quot; ]; then<br>    # 如果密码为空，则不使用 -p 选项<br>    mysqldump -u&quot;$&#123;DB_USER&#125;&quot; --host=&quot;$&#123;HOST&#125;&quot; -q -R --databases &quot;$&#123;DATABASE&#125;&quot; | gzip &gt; &quot;$&#123;BACKUP_DIR&#125;/$&#123;DATETIME&#125;.sql.gz&quot;<br>else<br>    # 如果密码不为空，则使用 -p 选项<br>    mysqldump -u&quot;$&#123;DB_USER&#125;&quot; -p&quot;$&#123;DB_PW&#125;&quot; --host=&quot;$&#123;HOST&#125;&quot; -q -R --databases &quot;$&#123;DATABASE&#125;&quot; | gzip &gt; &quot;$&#123;BACKUP_DIR&#125;/$&#123;DATETIME&#125;.sql.gz&quot;<br>fi<br><br>if [ $? -ne 0 ]; then<br>    echo &quot;$&#123;DATETIME&#125; - 数据库备份失败！&quot;<br>    exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 tar.gz 包</span><br>echo &quot;$&#123;DATETIME&#125; - 创建备份包...&quot;<br>tar -zcvf &quot;$&#123;BACKUP_DIR&#125;/$&#123;DATETIME&#125;.tar.gz&quot; -C &quot;$&#123;BACKUP_DIR&#125;&quot; &quot;$&#123;DATETIME&#125;.sql.gz&quot;<br><br>if [ $? -ne 0 ]; then<br>    echo &quot;$&#123;DATETIME&#125; - 创建备份包失败！&quot;<br>    exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除临时的备份文件</span><br>rm -f &quot;$&#123;BACKUP_DIR&#125;/$&#123;DATETIME&#125;.sql.gz&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除过期的备份文件</span><br>echo &quot;$&#123;DATETIME&#125; - 删除过期备份文件...&quot;<br>find &quot;$&#123;BACKUP_DIR&#125;&quot; -type f -name &quot;*.tar.gz&quot; -mtime +$&#123;RETENTION_DAYS&#125; -exec rm -f &#123;&#125; \;<br><br>if [ $? -ne 0 ]; then<br>    echo &quot;$&#123;DATETIME&#125; - 删除过期备份文件失败！&quot;<br>    exit 1<br>fi<br><br>echo &quot;$&#123;DATETIME&#125; - 数据库备份完成！&quot;<br><br></code></pre></td></tr></table></figure><h1 id="py-Ubuntu"><a href="#py-Ubuntu" class="headerlink" title="py-Ubuntu"></a>py-Ubuntu</h1><h2 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h2><blockquote><blockquote><p>Ubuntu(友帮拓、优般图、乌班图)是一个以面应用为主的开源GNU&#x2F;Linux操作系统支持x86、amd64(即x64)和p架构，由全球化的专业开Ubuntu 是基于 GNU&#x2F;Liu发团队(Canonical Ltd)打造的。</p></blockquote><p><strong>专业的Python开发者一般会选择 Ubuntu 这款Linux系统作为生产平台</strong></p><p><strong>温馨提示:</strong></p><p>Ubuntu 和 Centos 都是基于 GNU&#x2F;Linux 内核的，因此基本使用和Centos是几乎一样的它们的各种指令可以通用，同学们在学习和使用Ubuntu的过程中，会发现各种操作指令在面学习Centos都使用过。只是界面和预安装的软件有所差别。</p></blockquote><h2 id="2-安装（自己搜吧）"><a href="#2-安装（自己搜吧）" class="headerlink" title="2.安装（自己搜吧）"></a>2.安装（自己搜吧）</h2><blockquote><p>ubuntu安装比centos还简单一点</p></blockquote><h2 id="3-ubuntu汉化"><a href="#3-ubuntu汉化" class="headerlink" title="3.ubuntu汉化"></a>3.ubuntu汉化</h2><blockquote><p>1.设置Ubuntu支持中文</p><blockquote><p>默认安装的ubuntu 中只有英文语言，因此是不能显示汉字的。要正确显示汉字，需要安装中文语言包。</p></blockquote><p>2.安装中文支持步骤:</p><ul><li><p>1.单击左侧图标栏打开 Language support 菜单，点击打开Language Support(语言支持)选项卡。</p></li><li><p>2.点击Install&#x2F;Remove Languages，在弹出的选项卡中下拉找到Chinese(Simplified)，即中文简体，在后面的选项框中打勾。然后点击Apply Changes 提交，系统会自动联网下载中文语言包。(保证ubuntu 是联网的)。</p></li><li><p>3.这时“汉语(中国)”在最后一位因为当前第一位是”English”，所以默认显示都是英文。我们如果希望默认显示用中文，则应该将“汉语(中国)”设置为第一位。设置方法是拖动，鼠标单击“汉语(中国)当底色变化(表示选中了后，按住鼠标左键不松手，向上拖动放置到第一位。</p></li><li><p>4.设置后不会即刻生效，需要下次登录时才会生效</p></li></ul></blockquote><h2 id="4-ubuntu的root"><a href="#4-ubuntu的root" class="headerlink" title="4.ubuntu的root"></a>4.ubuntu的root</h2><blockquote><p>ubuntu的用户是弱用户</p></blockquote><blockquote><p>介绍</p><blockquote><p> 安装ubuntu成功后，都是普通用户权限，并没有最高root权限，如果需要使用root权限的时候，通常都会在命令前面加上 sudo 。有的时候感觉很麻烦。</p></blockquote><p>解决方法</p><blockquote><p><strong>我们一般使用su命令来直接切换到root用户的，但是如果没有给root设置初始密码就会抛出 <code>su:Authentication failure</code> 这样的问题。所以，我们只要给root用户设置一个初始密码就好了。</strong></p></blockquote><ul><li><p>给root用户设置密码并使用</p><ul><li><p>1.输入 <code>sudo passwd root</code> &#x2F;<code>su -</code>命令，设定root用户密码</p></li><li><p>2.设定root密码成功后，输入su 命令，并输入刚才设定的root密码，就可以切换成root了。提示符$代表一般用户，提示符#代表root用户。</p></li><li><p>3.以后就可以使用root用户了</p></li><li><p>4.输入 exit 命令，退出root并返回一般用户</p></li></ul></li></ul></blockquote><h2 id="5-python"><a href="#5-python" class="headerlink" title="5.python"></a>5.python</h2><blockquote><p>1.说明</p><blockquote><p>安装好Ubuntu后，默认就已经安装好Python的开发环境</p></blockquote><p>2.在Ubuntu下开发一个Python程序</p><p><code>vi hello.py </code>    &#x3D;&#x3D;&#x3D;&gt;[编写hello.py] </p><p><code>python3 hello.py</code>    &#x3D;&#x3D;&#x3D;&#x3D;&gt;  [运行hello.py]</p></blockquote><h2 id="6-apt原理"><a href="#6-apt原理" class="headerlink" title="6.apt原理"></a>6.apt原理</h2><h3 id="1-介绍-3"><a href="#1-介绍-3" class="headerlink" title="1.介绍"></a>1.介绍</h3><blockquote><p>apt是Advanced Packaging Tool的简称，是一款安装包管理工具。在Ubuntu下，我们可以使用apt命令进行软件包的安装、删除、清理等，类似于Windows中的软件管理工具。原理图如下：</p><p>unbuntu 软件管理的原理示意图</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240911160448119.png" class title="image-20240911160448119"></blockquote><h3 id="2-更新apt源，和实例"><a href="#2-更新apt源，和实例" class="headerlink" title="2.更新apt源，和实例"></a>2.更新apt源，和实例</h3><h4 id="1-实例命令"><a href="#1-实例命令" class="headerlink" title="1.实例命令"></a>1.实例命令</h4><blockquote><p><code>sudo apt-get update</code> <strong>更新源</strong></p><p><code>sudo apt-get install package</code> <strong>安装包</strong></p><p><code>sudo apt-get remove package</code> <strong>删除包</strong></p><p><code>sudo apt-cache search package</code> 搜索软件包</p><p><code>sudo apt-cache show paIkage</code> <strong>获取包的相关信息，如说明、大小、版本等</strong></p><p><code>sudo apt-get install package --reinstall</code>重新安装包</p><p><code>sudo apt-get -f install</code> 修复安装</p><p><code>sudo apt-get remove package --purge</code> 删除包，包括配置文件等</p><p><code>sudo apt-get build-dep package</code> 安装相关的编译环境</p><p><code>sudo apt-get upgrade</code> 更新已安装的包</p><p><code>sudo apt-get dist-upgrade</code> 升级系统</p><p><code>sudo apt-cache depends package</code> 了解使用该包依赖那些包</p><p><code>sudo apt-cache rdepends package</code> 查看该包被哪些包依赖</p><p><code>sudo apt-get source package</code> <strong>下载该包的源代码</strong></p></blockquote><h4 id="2-修改源（这里演示的版本是20-04）"><a href="#2-修改源（这里演示的版本是20-04）" class="headerlink" title="2.修改源（这里演示的版本是20.04）"></a>2.修改源（这里演示的版本是20.04）</h4><blockquote><p>1.先备份一份原文件</p><ul><li><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</code></li></ul><p>2.切换root用户，在<code>/etc/apt</code>目录下，并清空源文件</p><ul><li><code>su root</code></li><li><code>cd /etc/apt</code></li><li><code>echo &#39;&#39; &gt; sources.list</code></li></ul><p>3.先找到<code>https://mirrors.tuna.tsinghua.edu.cn/</code>步骤如下：</p><ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240911162216281.png" class title="image-20240911162216281"></li><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240911162547654.png" class title="image-20240911162547654"></li><li><p>将内容复制到对应的源文件后，更新源即可</p></li></ul><p>4.更新源（刷新）</p><ul><li><code>sudo apt-get update</code></li></ul><p>5.案例说明:使用apt完成安装和卸载vim 软件，并査询 vim 软件的信息:(因为使用了镜像网站 ，速度很快)</p><ul><li><p><code>sudo apt-get remove vim</code>  #删除</p></li><li><p><code>sudo apt-get install vim</code>  #安装</p></li><li><p><code>sudo apt-cache show vim</code>  #获取vim的信息</p></li></ul></blockquote><h2 id="7-远程登录"><a href="#7-远程登录" class="headerlink" title="7.远程登录"></a>7.远程登录</h2><h3 id="1-ssh"><a href="#1-ssh" class="headerlink" title="1.ssh"></a>1.ssh</h3><blockquote><p>1.ssh介绍</p><blockquote><p>SSH为Secure Shell的缩写，由IETF 的网络工作小组(Network Working Group)所制定;SSH 为建立在应用层和传输层基础上的安全协议。</p></blockquote><blockquote><p>SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。常用于远程登录几乎所有UNIX&#x2F;LInux 平台都可运行SSH。</p></blockquote><blockquote><p>使用SSH服务，需要安装相应的服务器和客户端。客户端和服务器的关系:如果，A机器想被B机器远程控制，那么，A机器需要安装SSH服务器，B机器需要安装SSH客户端。</p></blockquote><p>2.原理图</p><blockquote><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240911163744354.png" class title="image-20240911163744354"></blockquote><p>3.注意：</p><p><strong>和CentOS不一样，Ubuntu默认没有安装SSHD服务(使用<code>netstat</code> 指令查看22端口，若没安装netstat则执行 <code>apt installnet-tools</code>进行安装再执行<code>netstat</code>查看),发现没有22端口，因此，我们不能进行远程登录。</strong></p><p>4.安装SSH和启用</p><ul><li><p>1.<code>sudo apt-get install openssh-server</code></p><ul><li>执行上面指令后，<strong>在当前这台Linux上就安装了SSH服务端和客户端</strong></li><li>若不执行下面命令，则现在只有ssh客户端</li></ul></li><li><p>2.<code>service sshd restart</code></p><ul><li>执行上面的指令，就启动了 sshd 服务。会监听端口22</li></ul></li></ul></blockquote><h3 id="2-集群"><a href="#2-集群" class="headerlink" title="2.集群"></a>2.集群</h3><p>1.从一台linux系统远程登陆另外一台linux系统</p><blockquote><blockquote><p>在创建服务器集群时，会使用到该技术</p></blockquote><p>1.基本语法:</p><ul><li>ssh 用户名@IP</li><li>例如:ssh <a href="mailto:&#x68;&#115;&#112;&#x65;&#x64;&#x75;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x32;&#48;&#x30;&#46;&#50;&#x32;&#x32;">&#x68;&#115;&#112;&#x65;&#x64;&#x75;&#x40;&#x31;&#57;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x32;&#48;&#x30;&#46;&#50;&#x32;&#x32;</a></li></ul><blockquote><p>使用ssh访问，如访问出现错误。可查看是否有该文件~&#x2F;.ssh&#x2F;known ssh 尝试删除该文件解决，一般不会有问题</p></blockquote><p>2.登出</p><ul><li>登出命令:<code>exit</code>或者<code>logout</code></li></ul></blockquote><h1 id="centos8安装和介绍"><a href="#centos8安装和介绍" class="headerlink" title="centos8安装和介绍"></a>centos8安装和介绍</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><h2 id="2-CentOS8-0-vs-CentOS7-0的区别"><a href="#2-CentOS8-0-vs-CentOS7-0的区别" class="headerlink" title="2.CentOS8.0 vs CentOS7.0的区别"></a>2.CentOS8.0 vs CentOS7.0的区别</h2><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912121818091.png" class title="image-20240912121818091"><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="1-介绍-4"><a href="#1-介绍-4" class="headerlink" title="1.介绍"></a>1.介绍</h2><blockquote><p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。</p><p>日志对于安全来说也很重要，它记录了系统每天发生的各和事情，通过日志来检查错误发生的原因或者受到攻击时攻击者留下的痕迹。</p><p>可以这样理解 日志是用来记录重大事件的工具</p></blockquote><p>2.<code>/var/log/ </code>目录就是系统日志文件的保存位置，看张图</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912122039064.png" class title="image-20240912122039064"><p>3.系统常用的日志</p><table><thead><tr><th align="center">日志文件</th><th>说明</th></tr></thead><tbody><tr><td align="center"><strong>&#x2F;var&#x2F;log&#x2F;boot.log</strong></td><td>系统启动日志</td></tr><tr><td align="center"><strong>&#x2F;var&#x2F;log&#x2F;cron</strong></td><td>记录与系统定时任务相关的日志</td></tr><tr><td align="center">&#x2F;var&#x2F;log&#x2F;cups&#x2F;</td><td>记录打印信息的日志</td></tr><tr><td align="center">&#x2F;var&#x2F;log&#x2F;dmesg</td><td>记录了系统在开机时内核自检的信总。也可以使用dmesg命令直接查看内核自检信息</td></tr><tr><td align="center">&#x2F;var&#x2F;log&#x2F;btmp</td><td>记录错误登陆的日志。这个文件是二进制文件，不能直接用Vi查看，而要使用<code>lastb</code>命令查看。命令如下<code>[root@localhost log]# lastb</code></td></tr><tr><td align="center"><strong>&#x2F;var&#x2F;log&#x2F;lastlog</strong></td><td>记录系统中所有用户最后一次的登录时间的日志。这个文件也是二进制文件，所以直接使用<code>lastlog</code>命令查看，这个命令会直接找到这个文件，并查看</td></tr><tr><td align="center"><strong>&#x2F;var&#x2F;log&#x2F;mailog</strong></td><td>记录邮件信息的日志</td></tr><tr><td align="center"><strong>&#x2F;var&#x2F;log&#x2F;message</strong></td><td>记录系统重要消息的日志，这个日志文件中会记录Linux系统的绝大多数重要信息。<strong>如果系统出现问题，首先要查的应该就是这个日志文件</strong></td></tr><tr><td align="center"><strong>&#x2F;var&#x2F;log&#x2F;secure</strong></td><td>记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录，比如<strong>系统的登录、ssh的登录</strong>、su切换用户sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中，使用<code>cat /var/log/secure</code>查看</td></tr><tr><td align="center">&#x2F;var&#x2F;log&#x2F;wtmp</td><td>永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。是二进制文件.而要使用<code>last</code>的令查看</td></tr><tr><td align="center"><strong>&#x2F;var&#x2F;tun&#x2F;ulmp</strong></td><td>记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。这个文件不能用Vi查看而要使田<code>w</code>  <code>who</code> <code>users</code>等命令查看，这些命令直接取的这个文件的信息</td></tr></tbody></table><h2 id="2-日志管理服务-rsyslogd"><a href="#2-日志管理服务-rsyslogd" class="headerlink" title="2.日志管理服务-rsyslogd"></a>2.日志管理服务-rsyslogd</h2><blockquote><ul><li>1.介绍</li></ul><blockquote><p>CentOs7.6日志服务是rsyslogd，CentOs6.x日志服务是syslogd。rsyslogd 功能更强大，rsyslogd 的使用、日志文件的格式，和 syslogd 服务兼容的。原理示意图（这个服务和日志的关系）</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912124749075.png" class title="image-20240912124749075"></blockquote><ul><li><p>2.查询 Linux 中的 rsyslogd 服务是否启动</p><ul><li><code>ps aux | grep &quot;rsyslog&quot; | grep -v &quot;grep</code> 或 <code>ps aux | grep &quot;rsyslog&quot;</code></li></ul></li><li><p>3.查询 rsyslogd 服务的自启动状态</p><ul><li><code>systemctl list-unit-files | grep rsyslog</code></li></ul></li></ul></blockquote><h2 id="3-日志服务配置文件"><a href="#3-日志服务配置文件" class="headerlink" title="3.日志服务配置文件"></a>3.日志服务配置文件</h2><p>1.了解</p><blockquote><p>配置文件: <code>/etc/rsyslog.conf</code></p><blockquote><p>编辑文件时的格式为: <code>*.* </code>  存放日志文件</p></blockquote><blockquote><p> <strong>其中第一个*代表日志类型，第二个*代表日志级别</strong></p></blockquote><ul><li>1.第一个*，代表日志类型，日志类型分为:</li></ul><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>auth</td><td>pam产生的日志</td></tr><tr><td>authpriv</td><td>ssh、ftp等登录信息的验证信息</td></tr><tr><td>corn</td><td>时间任务相关</td></tr><tr><td>kern</td><td>内核</td></tr><tr><td>lpr</td><td>打印</td></tr><tr><td>mail</td><td>邮件</td></tr><tr><td>mark(syslog)-rsyslog</td><td>服务内部的信息，时间标识##新闻组</td></tr><tr><td>news</td><td>新闻组</td></tr><tr><td>user</td><td>用户程序产生的相关信息</td></tr><tr><td>uucp</td><td>unix to nuix copy主机之间相关的通信</td></tr><tr><td>local 1-7</td><td>自定义的日志设备</td></tr></tbody></table><ul><li>2.第二个*，表日志级别，日志级别分为:</li></ul><table><thead><tr><th>级别</th><th>说明</th></tr></thead><tbody><tr><td>debug</td><td>有调试信息的，日志通信最多</td></tr><tr><td>info</td><td>一般信息日志，最常用</td></tr><tr><td>notice</td><td>最具有重要性的普通条件的信息</td></tr><tr><td>warning</td><td>警告级别</td></tr><tr><td>err</td><td>错误级别阻止某个功能或者模块不能正常工作的信息</td></tr><tr><td>crit</td><td>严重级别，阻止整个系统或者整个软件不能正常工作的信息</td></tr><tr><td>alert</td><td>需要立刻修改的信息</td></tr><tr><td>emerg</td><td>内核崩溃等重要信息</td></tr><tr><td>none</td><td>什么都不记录</td></tr></tbody></table><p><strong>注意:从上到下，级别从低到高，记录信息越来越少</strong></p><p>看图分享：红色箭头表示邮件的所有记录都记录到日志文件中</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912130043684.png" class title="image-20240912130043684"></blockquote><p>2.日志文件中的内容格式</p><blockquote><p>由日志服务 rsyslogd 记录的日志文件，日志文件的格式包含以下4列:</p><ul><li>1.事件产生的时间</li><li>2.产生事件的服务器的主机名</li><li>3.产生事件的服务名或程序名</li><li>4.事件的具体信息</li></ul><p>日志如何查看实例</p><ul><li>查看一下 &#x2F;var&#x2F;log&#x2F;secure 日志，这个日志中记录的是用户验证和授权方面的信息 来分析如何査</li><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912132954554.png" class title="image-20240912132954554"></li></ul></blockquote><h2 id="4-自定义日志服务"><a href="#4-自定义日志服务" class="headerlink" title="4.自定义日志服务"></a>4.自定义日志服务</h2><blockquote><p>1.日志管理服务应用实例</p><blockquote><p>在<code>/etc/rsyslog.conf</code> 中添加一个日志文件<code>/var/log/hsp.log</code>，当有事件发送时(比如sshd服务相关事件)，该文件会接收到信息并保存:给小伙伴演示 ，警量 的情况，看看是否有日志保存</p></blockquote><p>2.步骤：</p><ul><li>1.<code>vim /etc/rsyslog.conf</code><ul><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912133423680.png" class title="image-20240912133423680"></li></ul></li><li>2.创建文件 <code>&gt; /var/log/hsp.log</code></li><li>3.重启 <code>reboot</code></li></ul></blockquote><h2 id="5-日志轮替"><a href="#5-日志轮替" class="headerlink" title="5.日志轮替"></a>5.日志轮替</h2><p>基本介绍</p><blockquote><p>1.基本介绍</p><blockquote><p>日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后就会进行删除</p></blockquote><p>2.日志轮替文件命名</p><ul><li><p>centos7使用logrotate进行日志轮替管理，要想改变日志轮替文件名字，通过 <code>/etc/logrotate.conf </code>配置文件中<code>dateext</code>参数:</p><ul><li><p>如果配置文件中有<code>dateext</code>参数，那么日志会用日期来作为日志文件的后缀，例如<code>secure-20201010</code>。这样日志文件名不会重叠，也就不需要日志文件的改名，只需要指定保存日志个数，删除多余的日志文件即可。</p></li><li><p>如果配置文件中没有<code>dateext</code>参数，日志文件就需要进行改名了。<strong>当第一次进行日志轮替时，当前的“secure日志会自动改secure.1，然后会新建“secure”日志，用来保存新的日志。</strong>当第二次进行日志轮替时，<code>secure.1</code>会自动改名为<code>secure.2</code>，当前的<code>secure</code>日志会自动改名为<code>secure.1</code>，然后也会新建“secure”日志，用来保存新的日志，以此类推。</p><ul><li>解释： <code>/etc/logrotate.conf </code>配置文件是：<strong>全局的日志轮替策略配置文件，当然可以单独给某个日志文件指定策略</strong></li></ul></li></ul></li></ul></blockquote><p>logrotate配置文件</p><blockquote><p>logrotate 配置文件</p><p>&#x2F;etc&#x2F;logrotate.conf为logrotate的全局配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">see <span class="hljs-string">&quot;man logrotate&quot;</span> <span class="hljs-keyword">for</span> details</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rotate <span class="hljs-built_in">log</span> files weekly , 每周对日志文件进行一次轮替</span><br>weekly<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">keep 4 weeks worth of backlogs ,共保存4份日志文件，当建立新的日志文件时，旧的将会被删除</span><br>rotate 4<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">create new (empty) <span class="hljs-built_in">log</span> files after rotating old ones,创建新的空的日志文件，在日志轮替后</span><br>create<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">use <span class="hljs-built_in">date</span> as a suffix of the rotated file,使用日期作为日志轮替文件的后缀</span><br>dateext<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">uncomment this <span class="hljs-keyword">if</span> you want your <span class="hljs-built_in">log</span> files compressed ,日志文件是否压缩，如果取消注释，则日志会在转储的同时进行压缩</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">compress</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">RPM packages drop <span class="hljs-built_in">log</span> rotation information into this directory</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">包含 /etc/logrotate.d/ 目录中所有的子配置文件。也就, 是说会把这个目录中所有子配置文件读取进来</span><br>include /etc/logrotate.d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">下面是单独设置，优先级更高</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">no packages own wtmp and btmp -- we<span class="hljs-string">&#x27;ll rotate them here</span></span><br>/var/log/wtmp &#123;<br>    monthly #每月对日志文件进行一次轮替<br>    create 0664 root utmp #建立的新日志文件，权限是0664，所有者是root，所屏组是 utmp 组<br>    minsize 1M  #日志文件最小轮替大小是 1MB。也就是日志一定要超过 1MB3 才会轮替，否则就算时间达到一个月，也不进行日志转储<br>    rotate 1 #仅保留一个日志备份。也就是只有wtmp和wtmp.1日志保留而已<br>&#125;<br><br>/var/log/btmp &#123;<br>    missingok #如果日志不存在，则忽路该日志的警告信息<br>    monthly<br>create 0600 root utmp<br>    rotate 1<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">system-specific logs may be also be configured here.</span></span><br><br><br><br></code></pre></td></tr></table></figure></blockquote><p>6.日志轮替的参数说明</p><blockquote><p>logrotate配置文件参数说明<br>参数说明</p><table><thead><tr><th>参 数</th><th>参数说明</th></tr></thead><tbody><tr><td>daily</td><td>日志的轮替周期是每天</td></tr><tr><td>weekly</td><td>日志的轮替周期是每周</td></tr><tr><td>monthly</td><td>日志的轮替周期是每月</td></tr><tr><td>rotate 数字</td><td>保留的日志文件的个数。0指没有备份</td></tr><tr><td>compress</td><td>日志轮替时，旧的日志进行压缩</td></tr><tr><td>create mode owner group</td><td>建立新日志，同时指定新日志的权限与所有者和所属组</td></tr><tr><td>mail address</td><td>当日志轮替时，输出内容通过邮件发送到指定的邮件地址。</td></tr><tr><td>missingok</td><td>如果日志不存在，则忽略该日志的警告信息</td></tr><tr><td>notifempty</td><td>如果日志为空文件，则不进行日志轮替</td></tr><tr><td>minsize 大小</td><td>日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替</td></tr><tr><td>size 大小</td><td>日志只有大于指定大小才进行日志轮替，而不是按照时间轮替。</td></tr><tr><td>dateext</td><td>使用日期作为日志轮替文件的后缀。</td></tr><tr><td>sharedscripts</td><td>在此关键字之后的脚本只执行一次。</td></tr><tr><td>prerotate&#x2F;endscript</td><td>在日志轮替之前执行脚本命令。</td></tr><tr><td>postrotate&#x2F;endscript</td><td>在日志轮替之后执行脚本命令。</td></tr></tbody></table></blockquote><p>案例：</p><blockquote><p>把自己的日志加入日志轮替</p><ul><li><p>第一种方法是直接在&#x2F;etc&#x2F;logrotate.conf 配置文件中写入该日志的轮替策略</p></li><li><p>第二种方法是在&#x2F;etc&#x2F;logrotate.d&#x2F;目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被“include”到主配置文件中，所以也可以把日志加入轮替。</p></li></ul><blockquote><p><strong>推荐使用第二种方法，因为系统中需要轮替的日志非常多，如果全都直接写 入&#x2F;etc&#x2F;logrotate.conf 配置文件那么这个文件的可管理性就会非常差，不利于此文件的维护。</strong></p></blockquote><p>在&#x2F;etc&#x2F;logrotate.d&#x2F; 配置轮替文件一览</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912141202444.png" class title="image-20240912141202444"><p>案例操作流程</p><p>看一个案例,在<code>/etc/logrotate.conf </code>进行配置,或者直接在 <code>/etc/logrotate.d/</code>下创建文件<code>hsplog</code>编写如<br>下内容，具体轮替的效果 可以参考 <code>/var/log </code>下的<code>boot.log</code>情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">/var/log/hsp.log &#123;<br>    missingok #如果日志不存在，则忽路该日志的警告信息<br>    daily<br>copytruncate #copy替换<br>    rotate 7<br>    notifempty  #文件空的不轮替<br>&#125;<br></code></pre></td></tr></table></figure><p>最终会如下显示模板</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912141524512.png" class title="image-20240912141524512"></blockquote><h2 id="6-日志轮替机制"><a href="#6-日志轮替机制" class="headerlink" title="6.日志轮替机制"></a>6.日志轮替机制</h2><blockquote><p>日志轮替机制原理</p><blockquote><p>日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在<code>/etc/cron.daily/</code>目录，就会发现这个目录中是有<code>logrotate </code>文件(可执行)，<code>logrotate</code> 通过这个文件依赖定时任务执行的。</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912141853558.png" class title="image-20240912141853558"></blockquote><p>整体讲解图</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912142231959.png" class title="image-20240912142231959"></blockquote><h2 id="7-查看内存日志"><a href="#7-查看内存日志" class="headerlink" title="7.查看内存日志"></a>7.查看内存日志</h2><blockquote><p>特点：重启后内存日志清空</p></blockquote><blockquote><p>journalctl 可以查看内存日志,这里我们看看常用的指令</p><ul><li><code>journalctl</code>##查看全部</li><li><code>journalctl -n 3 </code>   ##查看最新3条</li><li><code>journalctl --since 19:00 --until 19:10:10 </code>#查看起始时间到结束时间的日志可加日期</li><li><code>journalctl -p err</code> ##报错日志</li><li><code>journalctl -o verbose</code> ##日志详细内容</li><li><code>journalctl PID=1245 _COMM=sshd</code> ##查看包含这些参数的日志(在详细日志查看)或者<code>journalctl | grep sshd</code></li></ul><p><strong>注意:<code>journalctl</code>查看的是内存日志，重启清空</strong></p><p>演示案例:</p><ul><li>使用<code>journalctl | grep sshd </code>来看看用户登录清空，<strong>重启系统</strong>，再次查询,看看日志有什么变化没有</li></ul></blockquote><h1 id="定制自己的Linux"><a href="#定制自己的Linux" class="headerlink" title="定制自己的Linux"></a>定制自己的Linux</h1><h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h2><blockquote><p>启动流程介绍:</p><p>制作Linux小系统之前，再了解-下Linux的启动流程:</p><ul><li><p>1.首先Linux要通过自检，检查硬件设备有没有故障</p></li><li><p>2.如果有多块启动盘的话，需要在BIOS中选择启动磁盘</p></li><li><p>3.启动MBR中的bootloader引导程序</p></li><li><p>4.加载内核文件</p></li><li><p>5.执行所有进程的父进程、老祖宗systemd</p></li><li><p>6.欢迎界面</p></li></ul><p>在Linux的启动流程中，加载内核文件时关键文件</p><ul><li><p>1)kernel文件:vmlinuz-3.10.0-957.el7.x86 64</p></li><li><p>2 )initrd文件: initramfs-3.10.0-957.el7.x86 64.img</p></li></ul></blockquote><h2 id="2-制定min-Linux思路分析"><a href="#2-制定min-Linux思路分析" class="headerlink" title="2.制定min Linux思路分析"></a>2.制定min Linux思路分析</h2><blockquote><blockquote><p>1.在现有的Linux系统(centos7.6)上加一块硬盘&#x2F;dev&#x2F;sdb，在硬盘上分两个分区，一个是&#x2F;boot，一个是&#x2F;，并将其格式化。需要明确的是，现在加的这个硬盘在现有的Linux系统中是&#x2F;dev&#x2F;sdb，但是，当我们把东西全部设置好时，要把这个硬盘拔除，放在新系统上，此时，就是&#x2F;dev&#x2F;sda</p></blockquote><blockquote><p>2.在&#x2F;dev&#x2F;sdb硬盘上，将其打造成独立的Linux系统，里面的所有文件是需要拷贝进去的</p></blockquote><blockquote><p>3.作为能独立运行的Linux系统，内核是一定不能少，要把内核文件和initramfs文件也一起拷到&#x2F;dev&#x2F;sdb上</p></blockquote><blockquote><p>4.以上步骤完成，我们的自制Linux就完成,创建一个新的linux虚拟机，将其硬盘指向我们创建的硬盘，启动即可</p></blockquote><p>原理图（总之就是sda的东西拷贝到sdb中 ，sdb则就是小型的linux）</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912144448180.png" class title="image-20240912144448180"></blockquote><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>首先，我们在现有的linux添加一块大小为20g的硬盘</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912144701955.png" class title="image-20240912144701955"><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912144801109.png" class title="image-20240912144801109"><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>添加完成后，点击确定，然后启动现有的linux(centos7.6)。通过<code>fdisk</code>来给我们的&#x2F;dev&#x2F;sdb进行分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">先看看硬盘，发现sdb没有分区和格式化也没有挂载</span><br>lsblk<br><span class="hljs-meta prompt_">#</span><span class="language-bash">格式化硬盘</span><br>fdisk /dev/sdb<br>n<br>p<br>回车<br>+500M<br>n<br>p<br>回车<br>回车<br>w<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">先看看硬盘，发现sdb分区了</span><br>lsblk<br></code></pre></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>接下来我们对&#x2F;dev&#x2F;sdb的分区进行格式化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfs.ext4 /dev/sdb1<br>mkfs.ext4 /dev/sdb2<br></code></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><p>创建目录，并挂载新的磁盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /mnt/boot /mnt/sysroot<br>mount /dev/sdb1 /mnt/boot<br>mount /dev/sdb2 /mnt/sysroot<br><br></code></pre></td></tr></table></figure><h3 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h3><p>安装grub,内核文件拷贝至目标磁盘（centos7.6安装的是grub2）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">grub2-install --root-directory=/mnt/dev/sdb<br><span class="hljs-meta prompt_">#</span><span class="language-bash">我们可以来看一下二进制确认我们是否安装成功</span><br>hexdump -C -n 512 /dev/sdb<br>cp -rf /boot/* /mnt/boot/<br></code></pre></td></tr></table></figure><h3 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h3><p>修改grub2&#x2F;grub.cfg 文件，标红的部分 是需要使用的 指令来查看 (最麻烦的)</p><blockquote><p>这个文件是用来指定那个盘是启动盘，那个是根目录盘</p></blockquote><p>1.先查看分区的uuid，一会在grub.cfg要用</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912150642488.png" class title="image-20240912150642488"><p>2.在 gmnub.c文件中 ,红色部分用 上面 sdb1 的 UUID 替换，蓝色部分用 sdb2的 UUID 来替换，紫色部分是添加的，表示selinux 给关掉，同时设定一下 init，告诉内核不要再去找这个程序了，不然开机的时候会出现错误的</p><p>操作：进入gurb.cfg文件，按照上面修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /mnt/boot<br>cd grub2<br>vim grub.cfg<br><br></code></pre></td></tr></table></figure><blockquote><p>1.修改uuid  </p></blockquote><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912151220960.png" class title="image-20240912151220960"><p>第二处</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912151554988.png" class title="image-20240912151554988"><blockquote><p>2.加一句话</p></blockquote><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912151459728.png" class title="image-20240912151459728"><p>第二处</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912151635175.png" class title="image-20240912151635175"><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h3><p>创建目标主机根文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -pv /mnt/sysroot/&#123;etc/rc.d,usr,var,proc,sys,dev,lib,lib64,bin,sbin,boot,srv,mnt,media,home,root&#125;<br></code></pre></td></tr></table></figure><h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><p>拷贝需要的bash(也可以拷贝你需要的指令)和库文件给新的系统使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">一些依赖的库文件</span><br>cp /lib64/*.* /mnt/sysroot/lib64<br><span class="hljs-meta prompt_">#</span><span class="language-bash">bash文件，不然系统都进不去  这里指令只拷贝了bash ，<span class="hljs-built_in">ls</span>都没有</span><br>cp /bin/bash /mnt/sysroot/bin/<br></code></pre></td></tr></table></figure><h3 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h3><p>现在我们就可以创建一个新的虚拟机，然后将默认分配的硬盘 移除掉，指向我们刚刚创建的磁盘即可.</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240912152513638.png" class title="image-20240912152513638"><h3 id="10"><a href="#10" class="headerlink" title="10."></a>10.</h3><p>这时，很多指令都不能使用，比如 ls,reboot 等，可以将需要的指令拷贝到对应的目录即可</p><h3 id="11"><a href="#11" class="headerlink" title="11."></a>11.</h3><p>如果要拷贝指令，<strong>重新进入到原来的 Linux系统拷贝相应的指令即可</strong>，比如：将 <code>/bin/ls </code>拷贝到 <code>/mnt/sysroot/bin</code> ，将<code>/sbin/reboot </code>拷贝到<code>/mnt/sysroot/sbin</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount /dev/sdb2 /mnt/sysroot/<br>cp /bin/ls /mnt/sysroot/bin/<br>cp /bin/systemctl /mnt/sysroot/bin/<br>cp /sbin/reboot /mnt/sysroot/sbin/<br></code></pre></td></tr></table></figure><h3 id="12"><a href="#12" class="headerlink" title="12."></a>12.</h3><p>再重新启动新的 1inux系统，就可以使用<code>ls</code>，<code>reboot</code>指令了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用方式是/bin/ls，因为没有环境</span><br>/bin/ls /home<br></code></pre></td></tr></table></figure><h1 id="阅读Linux源码"><a href="#阅读Linux源码" class="headerlink" title="阅读Linux源码"></a>阅读Linux源码</h1><blockquote><p>阅读linux0.01版的内核，还轻松</p></blockquote><p>源码目录展示</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913090148835-17261893102051.png" class title="image-20240913090148835"><p>min函数中方法的调用</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913091249337.png" class title="image-20240913091249337"><h2 id="1-内核升级"><a href="#1-内核升级" class="headerlink" title="1.内核升级"></a>1.内核升级</h2><blockquote><p>内核地址：<a href="https://www.kernel.org/">https://www.kernel.org/</a> 查看</p></blockquote><p>实例：</p><p>下载&amp;解压最新版（<strong>不是随便升级的，有兼容问题</strong>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">1.下载</span><br>wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.8.16.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2.解压</span><br>tar -zxvf linux-5.8.16.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">3.查看当前的内核版本</span><br>uname -a <br><span class="hljs-meta prompt_">#</span><span class="language-bash">4.查看系统内核,显示可以升级的内核</span><br>yum info kernel -q<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">5.升级内核</span><br>yun update kernel <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">6.查看已经安装的内核</span><br>yum list kernel -q<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">7.现在查看内核信息还是原来那个`<span class="hljs-built_in">uname</span> -a`</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">8.需要重新启动，然后会提示，你要进入那个内核</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">9.因为是兼容的 你之前安装的东西，用户信息 都还在，只是内核版本变高了</span><br></code></pre></td></tr></table></figure><h1 id="linux备份和恢复"><a href="#linux备份和恢复" class="headerlink" title="linux备份和恢复"></a>linux备份和恢复</h1><h2 id="1-介绍-5"><a href="#1-介绍-5" class="headerlink" title="1.介绍"></a>1.介绍</h2><blockquote><blockquote><p>实体机无法做快照，如果系统出现异常或者数据损坏，后果严重，要重做系统，所以我还会造成数据丢失。们可以使用备份和恢复技术</p></blockquote><p>Linux的备份和恢复很简单，有两种方式:</p><ul><li><p>1.把需要的文件(或者分区)用TAR打包就行，下次需要恢复的时候，再解压开覆盖即可</p></li><li><p>2.使用dump和restore命令</p></li></ul></blockquote><h2 id="2-dump操作说明"><a href="#2-dump操作说明" class="headerlink" title="2.dump操作说明"></a>2.dump操作说明</h2><h3 id="1-安装工具："><a href="#1-安装工具：" class="headerlink" title="1.安装工具："></a>1.安装工具：</h3><blockquote><blockquote><p>如果linux上没有 dump 和 restore 指令，需要先按照</p></blockquote><ul><li><p><code>yum -y install dump</code></p></li><li><p><code>yum -yinstall restore</code></p></li></ul></blockquote><h3 id="2-dump完成备份的语法"><a href="#2-dump完成备份的语法" class="headerlink" title="2.dump完成备份的语法"></a>2.dump完成备份的语法</h3><blockquote><ul><li><p>基本介绍</p><ul><li>dump 支持分卷和增量备份(所谓增量备份是指备份上次备份后 修改&#x2F;增加过的文件,也称差异备份)。</li></ul></li><li><p>dump语法说明</p><ul><li>dump[-cu]  [-f &lt;备份后文件名&gt;] [-T &lt;日期&gt;] [目录或文件系统] <ul><li>这个c是真正的数字 0 1 2 3 4 5 6 7 8 9  ，9之后又是0 重新增加。例如：<code>dump -0uj -f /opt/boot.bak.bz2 /boot</code></li></ul></li><li>dump [] -wW</li><li>参数说明：<ul><li>-c : 创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头<ul><li>-0 1 2 3 4 5 6 7 8 9 : 备份的层级。0为最完整备份，会备份所有文件。若指定0以上的层级，则备份至上一次备份以来修改或新增的文件,到9后，可以再次轮替.</li></ul></li><li>-f&lt;备份后文件名&gt;:指定备份后文件名</li><li>-j:<strong>调用 bzlib库压缩备份文件</strong>，也就是将备份后的文件压缩成bz2格式，让文件更小</li><li>-T&lt;日期&gt;:指定开始备份的时间与日期</li><li><strong>-u</strong>:备份完毕后，在<code>/etc/dumpdares</code>中记录备份的文件系统，层级，日期与时间等。</li><li>-t:指定文件名，若该文件已存在备份文件中，则列出名称</li><li>-W :显示需要备份的文件及其最后一次备份的层级，时间，日期。</li><li>-w与-W类似，但仅显示需要备份的文件。</li></ul></li></ul></li></ul></blockquote><h3 id="3-dump案例"><a href="#3-dump案例" class="headerlink" title="3.dump案例"></a>3.dump案例</h3><h4 id="1-dump备份分区"><a href="#1-dump备份分区" class="headerlink" title="1.dump备份分区"></a>1.dump备份分区</h4><blockquote><p>1.dump应用案例1</p><ul><li>将&#x2F;boot 目录(分区)所有内容备份到&#x2F;opt&#x2F;boot.bak0.bz2 文件中，备份层级为“0”<ul><li><code>dump -0uj -f /opt/boot.bak0.bz2 /boot</code></li></ul></li></ul><p>2.dump应用案例2</p><ul><li>在&#x2F;boot目录下增加一个文件，备份层级为“1”  (只备份上次使用层次“0”备份后发生过改变的数据)，<strong>注意比较看这次生成的备份文件 boot1.bak 有多大</strong><ul><li><code>dump -1uj -f /opt/boot.bak1.bz2 /boot</code></li></ul></li></ul><blockquote><p><strong>提醒:</strong> 通过dump命令在配合crontab 可以实现无人值守备份</p></blockquote><p>3.案例：</p><ul><li><p>dump -W</p><ul><li>显示需要备份的文件及其最后一次备份的层级，时间，日期</li></ul><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913104606755.png" class title="image-20240913104606755"></li><li><p>查看备份时间文件</p><ul><li><code>cat /etc/dumpdates</code></li></ul><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913104634872.png" class title="image-20240913104634872"></li></ul></blockquote><h4 id="2-dump备份目录"><a href="#2-dump备份目录" class="headerlink" title="2.dump备份目录"></a>2.dump备份目录</h4><blockquote><ul><li>dump 备份文件或者目录</li><li>前面我们在<strong>备份分区时，是可以支持增量备份的</strong>，如果备份<strong>文件或者目录，不再支持增量备份</strong>，即只能使用0级别备份</li><li>案例 ，使用dump 备份&#x2F;etc 整个目录<ul><li><code>dump -0j -f /opt/etc.bak.bz2 /etc</code></li></ul></li><li>#下面这条语句会报错,提示 DUMP: Only level 0 dumps are allowed on a subdirectory ，参数<code>-u</code>也不支持<ul><li><code>dump -1j -f /opt/etc.bak.bz2 /etc/</code></li></ul></li><li><strong>提醒：</strong>如果是重要的备份文件 ，比如数据区，建议将文件上传到其它服务器保存，<strong>不要将鸡蛋放在同一个篮子。</strong></li></ul></blockquote><h2 id="3-restore完成恢复说明"><a href="#3-restore完成恢复说明" class="headerlink" title="3.restore完成恢复说明"></a>3.restore完成恢复说明</h2><h3 id="1-介绍-6"><a href="#1-介绍-6" class="headerlink" title="1.介绍"></a>1.介绍</h3><blockquote><p>基本介绍</p><blockquote><p>restore 命令用来恢复已备份的文件，可以从dump 生成的备份文件中恢复原文件</p></blockquote></blockquote><h3 id="2-restore基本语法"><a href="#2-restore基本语法" class="headerlink" title="2.restore基本语法"></a>2.restore基本语法</h3><blockquote><p>restore基本语法</p><ul><li>restore [模式选项] [选项]</li></ul><blockquote><p><strong>说明：下面四个模式，不能混用，在一次命令中，只能指定一种</strong></p></blockquote><ul><li><p>模式</p></li><li><p>-C : 使用对比模式，将备份的文件与已存在的文件相互对比。</p></li><li><p>-i : 使用交互模式，在进行还原操作时，restors指令将依序询问用户</p></li><li><p>-r:  进行还原模式（最多）</p></li><li><p>-t : 查看模式，看备份文件有哪些文件</p></li><li><p>选项</p></li><li><p>-f &lt;备份设备&gt;:从指定的文件中读取备份数据，进行还原操作</p></li></ul></blockquote><h3 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h3><h4 id="案例一（比较）"><a href="#案例一（比较）" class="headerlink" title="案例一（比较）"></a>案例一（比较）</h4><blockquote><blockquote><p>restore 命令比较模式，就是比较备份文件和原文件的区别</p></blockquote><ul><li><p><code>mv /boot/hello.java /boot/hello100.java</code>  &#x2F;&#x2F;给原目录中的文件改名，再比较</p></li><li><p><code>restore -C -f boot.bak1.bz2</code>     &#x2F;&#x2F;注意和 最新的文件比较</p></li></ul><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913110519363.png" class title="image-20240913110519363"></blockquote><h4 id="案例二（查看）"><a href="#案例二（查看）" class="headerlink" title="案例二（查看）"></a>案例二（查看）</h4><blockquote><blockquote><p>restore命令查看模式，看备份文件有哪些数据&#x2F;文件</p></blockquote><p>测试</p><ul><li><code>restore -t -f boot.bak0.hz2</code></li></ul></blockquote><h4 id="案例3-还原文件"><a href="#案例3-还原文件" class="headerlink" title="案例3 (还原文件)"></a>案例3 (还原文件)</h4><blockquote><blockquote><p>restore 命令还原模式，<strong>注意细节：</strong>如果你有增量备份，需要把增量备份文件也进行恢复，有几个增量备份文件就要恢复几个，<strong>按顺序来恢复</strong>即可</p></blockquote><p>测试</p><ul><li><p><code>mkdir /opt/boottmp</code></p></li><li><p><code>cd /opt/boottmp</code></p></li><li><p><code>restore -r -f /opt/boot.bak0.bz2</code> &#x2F;&#x2F;恢复到第1次完全备份状态</p></li><li><p><code>restore -r -f /opt/boot.bak1.bz2</code> &#x2F;&#x2F;恢复到第2次增量备份状态</p></li></ul><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913111056752.png" class title="image-20240913111056752"></blockquote><h4 id="案例4（恢复目录）"><a href="#案例4（恢复目录）" class="headerlink" title="案例4（恢复目录）"></a>案例4（恢复目录）</h4><blockquote><p>restore 命令恢复备份的文件，或者整个目录的文件</p><p>基本语法:</p><p><code>restore -r -f 备份好的文件</code></p><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /opt/etctmp<br><br>cd /opt/etctmp/<br><br>restore -r -f/opt/etc.bak0.bz2<br></code></pre></td></tr></table></figure></blockquote><h1 id="webmin"><a href="#webmin" class="headerlink" title="webmin"></a>webmin</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><blockquote><blockquote><p>Webmin是功能强大的基于Web的Unix&#x2F;linux系统管理工具。管理员通过浏览器访问Webmin的各种管理功能并完成相应的管理操作。除了各版本的linux以外还可用于:AIX、HPUX、Solaris、Unixware、Irix和FreeBSD等系统</p></blockquote></blockquote><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><blockquote><p>安装webmin&amp;配置</p><p>1.下载地址 :<a href="http://download.webmin.com/download/yum/%EF%BC%8C%E7%94%A8%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%8D%B3%E5%8F%AF">http://download.webmin.com/download/yum/，用下载工具下载即可</a></p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913140037374.png" class title="image-20240913140037374"><blockquote><p>也可以使用 wget <a href="http://downlobmi.com/download/yum/webmin-1.700..noarch.rom">http://downlobmi.com/download/yum/webmin-1.700..noarch.rom</a></p></blockquote><p>2.安装:</p><ul><li><code>rpm -ivh webmin-1.700-1.noarch.rpm</code></li></ul><p>3.重置密码</p><ul><li><code>/usr/libexec/webmin/changepass.pl /etc/webmin root test</code></li></ul><blockquote><p><code>root</code>是webmin的用户名，不是OS的，这里就是把 webmin 的root 用户密码改成了 <code>test</code></p></blockquote><p>4.修改webmin服务的端口号(默认是10000 出于安全目的)</p><ul><li><code>vim/etc/webmin/miniserv.conf</code> #修改端口<ul><li>将<code>port=10000</code>修改为其他端口号，如port&#x3D;6666</li><li>将<code>listen=10000</code>修改为6666</li></ul></li></ul><p>5.重启webmin</p><ul><li><p><code>/etc/webmin/restart</code>  #重启</p></li><li><p><code>/etc/webmin/start</code>  #启动</p></li><li><p><code>/etc/webmin/stop</code> #停止</p></li></ul><p>6.防火墙放开6666端口</p><ul><li><p><code>firewall-cmd --zone=public --add-port=6666/tcp --permanent</code> # 配置防火墙开放6666端口</p></li><li><p><code>firewall-cmd --reload</code>  # 更新防火墙配置</p></li><li><p><code>firewall-cmd --zone=public --list-ports</code> #查看已经开放的端囗号</p></li></ul><p>7.登录webmin</p><ul><li><p><a href="http://ip:6666/">http://ip:6666</a> 可以访问了</p><ul><li>用root账号和重置的新密码test</li></ul><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913142437221.png" class title="image-20240913142437221"></li></ul></blockquote><h2 id="3-功能展示"><a href="#3-功能展示" class="headerlink" title="3.功能展示"></a>3.功能展示</h2><h3 id="1-简单展示"><a href="#1-简单展示" class="headerlink" title="1.简单展示"></a>1.简单展示</h3><blockquote><p>比如修改 语言设置，IP访问控制，查看进程,修改密码，任务调度，mysql 等</p></blockquote><p>1.语言设置：</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913143924263.png" class title="image-20240913143924263"><p>2.修改密码</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913143935880.png" class title="image-20240913143935880"><p>3.任务调度</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913143906895.png" class title="image-20240913143906895"><p>4.任务管理器</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913143849727.png" class title="image-20240913143849727"><p>5.mysql服务管理</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913144029502.png" class title="image-20240913144029502"><p>6.shell控制台</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913144202314.png" class title="image-20240913144202314"><p>7.ip访问</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913144234567.png" class title="image-20240913144234567"><h1 id="宝塔bt"><a href="#宝塔bt" class="headerlink" title="宝塔bt"></a>宝塔bt</h1><h2 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><blockquote><p>bt宝塔Linux面板是提升运维效率的服务器管理软件，支持一键LAMP&#x2F;LNMP&#x2F;集群&#x2F;监控&#x2F;网站&#x2F;FTP&#x2F;数据库&#x2F;JAVA等多项服务器管理功能。</p></blockquote><h2 id="2-安装和使用"><a href="#2-安装和使用" class="headerlink" title="2.安装和使用"></a>2.安装和使用</h2><blockquote><p>安装:</p><ul><li><p><code> yum install -y wget</code> </p></li><li><p><code>wget -0 install.sh http://download.bt.cn/install/install 6.0.sh </code></p></li><li><p><code> sh install.sh</code></p></li></ul><p>安装成功后控制台会显示登录地址，账户密码，复制浏览器打开登录</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913152419655.png" class title="image-20240913152419655"></blockquote><h2 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h2><blockquote><p>使用介绍，比如可以登录终端,配置，快捷安装运行环境和系统工具,添加计划任务脚本</p><p><a href="http://ip:8888/d3076f56/">http://ip:8888/d3076f56/</a></p></blockquote><h2 id="4-忘记密码"><a href="#4-忘记密码" class="headerlink" title="4.忘记密码"></a>4.忘记密码</h2><blockquote><p>如果bt的用户名，密码忘记了，使用<code>bt default</code>可以查看</p></blockquote><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913154646107.png" class title="image-20240913154646107"><h1 id="linux面试题"><a href="#linux面试题" class="headerlink" title="linux面试题"></a>linux面试题</h1><p>1.问题：分析日志t.log(访问量)，将各个ip地址截取，并统计出现次数,并按从大到小排序(腾讯)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">http://192.168.200.10/index1.html<br>http://192.168.200.10/index2.html<br>http://192.168.200.20/index1.html<br>http://192.168.200.30/index1.html<br>http://192.168.200.40/index1.html<br>http://192.168.200.30/order.html<br>http://192.168.200.10/order.html<br></code></pre></td></tr></table></figure><p>答案：</p><blockquote><p><code>cat t.txt | cut -d &#39;/&#39; -f 3 | sort | uniq -c | sort -nr</code> </p><p>解释：</p><ul><li>cut 类似于Java中的切割字符串</li><li>sort 排序<ul><li>-nr  反序</li></ul></li><li>uniq 统计相邻的重复情况  所以先排序再统计</li></ul></blockquote><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240913155749647.png" class title="image-20240913155749647"><p>2.问题：统计连接到服务器的各个ip情况，并按连接数从大到小排序(腾讯)</p><p>答案：</p><blockquote><ul><li><code>netstat -an |grep ESTABLISHED | awk -F &quot; &quot; &#39;&#123;print $5&#125;&#39; | awk -F &quot;:&quot; &#39;&#123;print $1&#125;&#39; | sort | uniq -c | sort -nr</code></li></ul><p>或者</p><ul><li><code>netstat -an |grep ESTABLISHED | awk -F &quot; &quot; &#39;&#123;print $5&#125;&#39; | cut -d &quot;:&quot; -f 1 | sort | uniq -c | sort -nr</code></li></ul><p>解释：</p><ul><li><code>awk -F &quot; &quot; &#39;&#123;print $1&#125;&#39;  </code> 分割字符串，可以分割空格，<code>cut</code>简单的可以分割，空格不能分割</li></ul></blockquote><p>3.问题：如忘记了mysql5.7数据库的ROOT用户的密码，如何找回?(滴滴)</p><ul><li><code>vim /etc/my.cnf</code>  </li><li>添加一行<code>skip-grant-tables</code>(跳过权限)</li><li>重启mysqld服务<code>service mysqld restart</code></li><li><code>mysql -u root -p</code> 空密码进入</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> databases;<br><span class="hljs-keyword">user</span> mysql;<br><span class="hljs-keyword">show</span> tables;<br><span class="hljs-keyword">desc</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> authentication_string<span class="hljs-operator">=</span>password(&quot;123456&quot;) <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;root&#x27;</span>;<br>flush privileges;<br>exit<br></code></pre></td></tr></table></figure><ul><li><code>vim /etc/my.cnf</code>  </li><li>注释<code>skip-grant-tables</code>(跳过权限)</li></ul><p>4.问题：写出指令:统计ip访问情况，要求分析nginx访问日志(access.log)，找出访问页面数量在前十位的ip(美团)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">192J168.130.21 aaa.html<br>192.168.130.20 aaa.html<br>192.168.130.20 aaa.html<br>192.168.130.20 aaa.htm]<br>192.168.130.23 aaa.html<br>192.168.130.20 aaa.html<br>192.168.130.25 aaa.html<br>192.168.130.20 aaa.html<br>192.168.130.20 aaa.html<br>192.168.130.25 aaa.html<br>192.168.130.20 aaa.html<br></code></pre></td></tr></table></figure><p>答案：</p><ul><li><code>cat access.log | awk -F &quot; &quot; &#39;&#123;print $1&#125;&#39; | sort | uniq -c | sort -nr | head -2 </code><ul><li><code>head -2</code>  取前两条</li></ul></li></ul><p>5.问题：使用tcpdump监听本机,将来自ip 192.168.200.1，tcp端口为22的数据，保存输出到tcpdump.log，用做将来数据分析(美团)</p><p>答案：</p><ul><li><code>tcpdump</code>  #验证装没装</li><li><code>tcpdump -i ens33 host 192.168.200.1 and port 22 &gt;&gt; /opt/interview/tcpdump.log</code></li></ul><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914090501116.png" class title="image-20240914090501116"><p>6.常用的Nginx模块，用来做什么(头条)</p><p>答案：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">rewrite模块，实现重写功能<br>access模块:来源控制<br>ssI模块:安全加密<br>ngx_http_gzip_module:网络传输压缩模块<br>ngx_http_proxy_module 模块实现代理<br>ngx_http_upstream_module<br>模块实现定义后端服务器列表<br>ngx_cache_purge实现缓存清除功能<br>...还有很多<br></code></pre></td></tr></table></figure><p>7.如果你是系统管理员，在进行Linux系统权限划分时,应考虑哪些因素?(腾讯)</p><p>第一：首先阐述Linux权限的主要对象</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914091004808.png" class title="image-20240914091004808"><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914090951770.png" class title="image-20240914090951770"><p>第二：根据自己实际经验谈考虑因素</p><blockquote><ul><li><p>1.注意权限分离，比如: 工作中，Linux系统权限和数据库权限不要在同一个部门</p></li><li><p>2.权限最小原则(即:在满足使用的情况下最少优先)</p></li><li><p>3.减少使用<code>root用户</code>，尽量用<code>普通用户+sudo</code>提权进行日常操作。</p></li><li><p>4.重要的系统文件，比如<code>/etc/passwd,/etc/shadow etc/fstab，/etc/sudoers</code> 等,日常建议使用<code>chattr</code> (change attribute的缩写)锁定，需要操作时再打开。【演示 比如: 锁定&#x2F;etc&#x2F;password 让任何用户都不能随意<code>useradd</code>，除非解除锁定】</p><ul><li>​<code>chattr +i /etc/passwd </code> #锁定这个文件后 所有用户都不能<code>useradd myuser</code></li><li>防止黑客执行<code>chattr</code>命令，将<code>chattr</code>命令藏起来：<ul><li><code>which chattr</code>  #找到这个命令的位置</li><li><code>mv /usr/bin/chattr /opt</code>  #将这个命令转移，这样就不能直接使用这个命令了</li><li><code>mv /opt/chattr /opt/h</code>   #怕黑客使用<code>find / -name chattr</code>找到 则修改这个命令的名字</li></ul></li><li>解锁的过程是防黑客的逆操作<ul><li><code>mv /opt/h /opt/chattr</code></li><li><code>mv /opt/chattr /usr/bin/</code></li><li><code>chattr -i /etc/passwd</code>  #命令还原后解锁</li></ul></li></ul></li><li><p>5.使用<code>SUID, SGID, Sticky</code> 设置特殊权限。</p></li><li><p>6.可以利用工具，比如<code>chkrootkit</code> 或者<code>rootkit hunter </code>检测rootkit脚本(rootkit是入侵者使用工具,在不察觉的建立了入侵系统途径)[演示使用 <code>wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz</code>]</p><ul><li>下载后，执行<code>./chrootkit</code> 扫描  （解压后可以<code>gcc</code>进行编译（可选））</li></ul></li><li><p>7.利用工具<code>Tripwire</code> 检测文件系统完整性</p></li></ul></blockquote><p>8.权限思考</p><blockquote><p>权限操作思考题</p><p>1.用户tom 对目录<code>/home/test</code>有执行和读写权限，<code>/home/test/hello.java</code> 是只读文件，问tom对<code>hello.java</code>文件能读吗？能修改吗？能删除吗？</p><ul><li>能读，不能修改，能删除</li></ul><p>2.用户tom 对目录 &#x2F;home&#x2F;test 只有读写权限，&#x2F;home&#x2F;test&#x2F;hello.java 是只读文件,问tom对 hello.java文件能读吗?能修改吗?能删除吗?</p><p>不能，不能，不能</p><p>3.用户tom 对目录 &#x2F;home&#x2F;test 只有执行权限,&#x2F;home&#x2F;test&#x2F;hello.java 是只读文件,问tom对 hello.java文件能读吗?能修改吗 ?能删除吗?</p><p>能，不能，不能</p><p>4.用户tom 对目录 &#x2F;home&#x2F;test 只有执行和写权限，&#x2F;home&#x2F;test&#x2F;hello.java 是只读文件，问tom对hello.java文件能读吗?能修改吗?能删除吗?</p><p>能，不能，能</p></blockquote><p>9.说明Centos7启动流程，并说明和CentOs6相同和不同的地方(腾讯)</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914134312443.png" class title="image-20240914134312443"><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914134328917.png" class title="image-20240914134328917"><p>流程图</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914134452700.png" class title="image-20240914134452700"><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914134526830.png" class title="image-20240914134526830"><p>结合两图讲解：</p><blockquote><p>第一步、硬件启动阶段</p><ul><li>这一步和 Centos6 差不多，详细请看图</li></ul><p>第二步、GRUB2引导阶段</p><ul><li><p>从这一步开始,CentOs6和 Centos7 的启动流程区别开始展现出来了。Cent0s7的主引导程序使用的是 grub2。</p></li><li><p>这一步的流程:显示加载两个镜像，再加载MOD 模块文件，把 grub2 程序加载执行，接着解析配置文件&#x2F;boot&#x2F;grub2&#x2F;grub.cg，根据配置文件加载内核镜像到内存，之后构建虚拟根文件系统，最后转到内核。</p></li><li><p>在这里 grub.cfg 配置文件已经比较复杂了，但并不用担心，到了 Cent0s7 中一般是使用命令进行配置，而不直接去修改配置文件了。不过我们可以看到grub.cfg配置文件开头注释部分说明了由&#x2F;etc&#x2F;grub.d&#x2F;目录下文件和&#x2F;etc&#x2F;default&#x2F;grub 文件组成。</p></li><li><p>一般修改好配置后都需要使用命令grub2-mkconfig:o&#x2F;boot&#x2F;grub2&#x2F;grub.cfg，将配置文件重新生成。</p></li></ul><p>第三步、内核引导阶段</p><ul><li>这一步与 CentOs6 也差不多，加载驱动，切换到真正的根文件系统，唯一不同的是执行的初始化程序变成了&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd</li></ul><p>第四步、systemed初始化阶段(又叫系统初始化阶段)</p><ul><li><p>Cent0s7 中我们的初始化进程变为了systemd,执行默认target 配文件<code>/etc/systemd/system/default.target</code>(这是一个软链接，与默认运行级别有关)。然后执行<code>sysinit.target </code>来初始化系统和 <code>basic.target</code> 来准备操作系统。接着启动 <code>multi-user.target</code>下的本机与服务器服务，并检査<code>/etc/rc.d/rc.local</code>文件是否有<strong>用户自定义脚本</strong>需要启动。最后执行<code>multi-user</code>下的 <code>getty.target </code>及登录服务，检查 <code>default.target </code>是否有其他的服务需要启动。</p></li><li><p>注意:<code>/etc/systemd/system/defaulttarget</code>指向了<code>/lib/systemd/system/</code>目录下的<code>graphical.target</code> 或<code>multiuser.target</code>。而<code>graphical.target </code>依赖<code>multiuser.target</code>, <code>multiuser.target</code> 依赖 <code>basic.target</code>， <code>basic.target</code> 依赖<code>sysinit.target</code>，所以倒过来执行。</p></li><li><p>System 概述(了解):<code>systemd</code> 即为<code>system daemon</code>，是Linux 下的一种<code>init </code>软件，开发目标是提供更优秀的框架以表示系统服务间的以来关系，并依此实现系统初始化时服务的并行启动，同时达到降低<code>shell</code>系统开销的效果，最终代替现在常用的<code>System V</code>与 <code>BSD </code>风格的<code>init</code> 程序。</p></li><li><p>与多数发行版使用的 <code>System V</code>风格的<code>init</code>相比，<code>systemd</code>采用了以下的新技术:A.采用 <code>Socket</code>激活式与总线激活式服务，以提高相互依赖的各服务的并行运行性能；B.用<code>Cgroup</code>代替<code>PID</code>来追踪进程，即使是两次 <code>fork</code>之后生成的守护进程也不会脱离 <code>systemd</code> 的控制。</p></li><li><p>unit 对象:<code>unit </code>表示不同类型的<code>systemd</code> 对象，通过配置文件进行标识和配置;文件中主要包含了系统服务、监听 socket、保存的系统快照以及其他与 init 相关的信息。(也就是CentOs6中的服务器启动脚本)</p><ul><li><p>(1).<code>/etc/systemd/system/default.target</code>  这是一个软链接，和默认运行级别相关</p><ul><li><p>我们可以到这个目录下看一下 <code>cd /lib/systemd/system/ &amp;&amp; ls *.target</code>  </p></li><li><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914135904070.png" class title="image-20240914135904070"></li></ul></li><li><p>这里可以看到runlevel开头的target文件，对应着Centos6 的启动级别，不过一样是软链接，指向了同目录下的其他文件，也算一种向下兼容吧</p><ul><li><p><code>ll runlevel*.target</code></p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914140029729.png" class title="image-20240914140029729"></li><li><p>可以看到我的 default.target 与 runlevel5.target指向的是同一个文件，可以看出我的默认运行级别是 5。</p></li></ul></li><li><p>(2).<code>/usr/lib/systemd/system/</code></p><ul><li>这个目录存储每个服务的脚本，类似CentOs6 的<code>/etc/init.d/</code></li></ul></li><li><p>(3).<code>/run/systemd/system/</code></p><ul><li>系统执行过程中产生的脚本。</li></ul></li><li><p>(4).<code>/etc/systemd/system/</code></p><ul><li>类似于 CentOs6 的&#x2F;etc&#x2F;rc.d&#x2F;rc#.d&#x2F;sxx类文件的功能，管理员建立的执行脚本，大部分是软链接</li></ul></li></ul></li></ul></blockquote><p>10.问题:列举 Linux高级命令，至少6个(百度)</p><p>答案：</p><blockquote><p>-<br>  netstat &#x2F;&#x2F;网络状态监控</p><ul><li><p>top &#x2F;&#x2F;系统运行状态</p></li><li><p>lsblk &#x2F;&#x2F;查着硬盘分区</p></li><li><p>find</p></li><li><p>ps -aux &#x2F;&#x2F;查看运行进程</p></li><li><p>chkconfig &#x2F;&#x2F;查看服务启动状态</p></li><li><p>systemctl &#x2F;&#x2F;管理系统服务器</p></li></ul></blockquote><p>11.问题:Linux查看内存、io 读写、磁盘存储、端口占用、进程查看命令是什么?(瓜子)</p><p>答案：</p><blockquote><p>1.<code>top</code> 内存</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914141325361.png" class title="image-20240914141325361"><p>2.<code>yum install iotop</code> 安装io查询</p><p><code> iotop</code></p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914141644228.png" class title="image-20240914141644228"><p>3.df -lh  </p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914141717646.png" class title="image-20240914141717646"><p>4.<code>netstat -tunlp</code>  只查询端口占用情况</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914141758657.png" class title="image-20240914141758657"><p>5.<code>ps -aux | grep sshd</code> 进程查看情况</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914141936826.png" class title="image-20240914141936826"></blockquote><p>12.使用Linux命令计算t2.txt 第二列的和并输出(美团)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">张三 40<br>李四 50<br>王五 60<br></code></pre></td></tr></table></figure><p>答案：</p><p><code>cat t2.txt | awk -F &quot; &quot; &#39;&#123;sum+=$2&#125; END &#123;print sum&#125;&#39; </code></p><p>13.Shell脚本里如何检查一个文件是否存在?并给出提示(百度)</p><p>答案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ -f 文件名 ]<br>then <br>echo &quot;存在&quot;<br>else echo “不存在”<br>fi<br></code></pre></td></tr></table></figure><p>14.用shell写一个脚本，对文本t3.txt 中无序的一列数字排序,并将总和输出(百度)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">9<br>8<br>7<br>6<br>5<br>4<br>3<br>2<br>10<br></code></pre></td></tr></table></figure><p>答案：<code>sort -n t3.txt | awk &#39;&#123;sum+=$0; print $0&#125; END &#123;print &quot;和=&quot;sum&#125;&#39;</code></p><p>15.请用指令写出查找当前文件夹(&#x2F;home)下所有的文本文件内容中包含有字符<code>cat</code>的文件名称(金山)</p><p>答案：</p><p><code>grep -r &quot;cat&quot; /home | cut -d &quot;:&quot; -f 1 </code></p><p>16.请写出统计&#x2F;home目录下所有文件个数和所有文件总行数的指令(在金山面试题扩展)</p><p>答案：</p><p><code>find /home/test -name &quot;*.*&quot; | wc -l</code>    #统计&#x2F;home目录下所有文件个数</p><p><code>find /home/test -name &quot;*.*&quot; | xargs wc -l</code>  # 统计&#x2F;home目录下所有文件总行数的指令</p><p>17.列出你了解的web服务器负载架构(滴滴)</p><p>答案：</p><blockquote><p>Nginx</p><p>Haproxy</p><p>Keepalived</p><p>LVS</p></blockquote><p>18.每天晚上 10 点30分，打包站点目录&#x2F;var&#x2F;spool&#x2F;mail 备份到&#x2F;home 目录下(每次备份按时间生成不同的备份包，比如按照 年月日时分秒)(滴滴)</p><p>答案：</p><blockquote><ul><li>在&#x2F;root中写脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>cd /var/spool/ &amp;&amp; /bin/tar zcf /home/mail-`date +%Y-%m-%d_%H%M%S`.tar.gz mail/<br></code></pre></td></tr></table></figure><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914152057752.png" class title="image-20240914152057752"><ul><li>写定时器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">crontab -e<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">mail.sh没有执行权限这样写（30 20 * * * /bin/sh /root/mail.sh），有执行权限则如下</span><br>30 20 * * * /root/mail.sh<br><br>crontab -i<br></code></pre></td></tr></table></figure></blockquote><p>19.如何优化Linux系统，说出你的方法(瓜子)</p><blockquote><p>1.架构层次</p><img src="/2024/09/12/Linux%E5%85%A5%E9%97%A8/image-20240914153120348.png" class title="image-20240914153120348"><p>2.对linux本身的优化</p><blockquote><p>(1)不用root,使用sudo提示权限</p><p>(2)定时的自动更新服务时间,使用<code>ntpdate ntp1.aliyun.com</code>，让<code>crond </code>定时更新</p><ul><li>ntpdate已经不建议使用，新系统使用ntpsec-ntpdate。</li></ul><p>(3)配置yum源，指向国内镜像(清华，163)</p><p>(4)配置合理的防火墙策略,打开必要的端口，关闭不必要的端口</p><p>(5)打开最大文件数(专业术语：调整文件的描述的数量) 在<code>vim /etc/profile</code> 文件中添加<code> ulimit -SHn 65535</code></p><p>(6)配置合理的监控策略</p><p>(7)配置合理的系统重要文件的备份策略</p><p>(8)对安装的软件进行优化，比如<code>nginx</code>,<code>apache</code></p><p>(9)内核参数进行优化<code>/etc/sysctl.conf</code></p><p>(10)锁定一些重要的系统文件 <code>chattr </code>  ，例如锁定这些文件 <code>/etc/passwd</code> <code>/ect/shadow </code> <code>/etc/inittab</code></p><p>(11)禁用不必要的服务 <code>setup</code>或 <code>ntsysv</code></p></blockquote></blockquote><h1 id="补充命令"><a href="#补充命令" class="headerlink" title="补充命令"></a>补充命令</h1><p>1.scp命令</p><blockquote><blockquote><p>跨服务复制:  <code>scp</code>&#x3D;<code>ssh cp</code></p></blockquote><p>语法：</p><ul><li>scp [-r] 参数1 参数2<ul><li><code>-r</code> 选项用于复制文件夹使用，如果复制文件来，必须使用-r</li><li>参数1:本机路径 或 远程目标路径</li><li>参数2:远程目标路径 或 本机路径</li></ul></li><li>案例：<ul><li>如:<code>scp -r /export/server/jdk root@node2:/export/server/</code>将本机上的jdk文件来，以root的身份复制到node2的&#x2F;export&#x2F;server&#x2F;内同SSH登陆一样，账户名可以省略(使用本机当前的同名账户登陆)</li><li>如:<code>scp -r node2:/export/server/idk /export/server/</code>将远程node2的jdk文件夹，复制到本机的&#x2F;export&#x2F;server&#x2F;内</li><li>#scp命令的高级用法<ul><li><code>cd /export/server</code></li><li>scp -r jdk node2:`pmd`  #将本机当前路径的jdk文件夹，复制到node2服务器的同名路径下</li><li>&#x2F;scp -r jdk node2:$PWD  #将本机当前路径的jdk文件夹，复制到node2服务器的同名路径下</li></ul></li></ul></li></ul></blockquote><p>2.env 命令</p><blockquote><p><code>env</code> 查看所有的环境变量，配合<code>$</code> 如：<code>$pwd</code></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
